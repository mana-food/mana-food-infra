# filepath: .github/workflows/cd-deploy.yml
name: Deploy Mana Food - Infraestrutura Robusta

on:
  workflow_dispatch:
    inputs:
      deploy_mode:
        description: "Modo de deploy"
        type: choice
        options:
          - "infra-only"
          - "full-with-fallback"
          - "full-with-repos"
        default: "infra-only"
  push:
    branches:
      - main

permissions:
  contents: read
  packages: write
  id-token: write

jobs:
  check-repositories:
    name: 'Verificar Reposit√≥rios'
    runs-on: ubuntu-latest
    outputs:
      lambda-available: ${{ steps.check-lambda.outputs.available }}
      app-available: ${{ steps.check-app.outputs.available }}
      deploy-mode: ${{ steps.determine-mode.outputs.mode }}

    steps:
      - name: Verificar repo Lambda
        id: check-lambda
        continue-on-error: true
        run: |
          if curl -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
             -s "https://api.github.com/repos/mana-food/mana-food-lambda" | grep -q '"private"'; then
            echo "available=true" >> $GITHUB_OUTPUT
            echo "‚úÖ Reposit√≥rio Lambda acess√≠vel"
          else
            echo "available=false" >> $GITHUB_OUTPUT
            echo "‚ùå Reposit√≥rio Lambda n√£o acess√≠vel"
          fi

      - name: Verificar repo App
        id: check-app
        continue-on-error: true
        run: |
          if curl -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
             -s "https://api.github.com/repos/mana-food/mana-food-clean-architecture" | grep -q '"private"'; then
            echo "available=true" >> $GITHUB_OUTPUT
            echo "‚úÖ Reposit√≥rio App acess√≠vel"
          else
            echo "available=false" >> $GITHUB_OUTPUT
            echo "‚ùå Reposit√≥rio App n√£o acess√≠vel"
          fi

      - name: Determinar modo de deploy
        id: determine-mode
        run: |
          INPUT_MODE="${{ github.event.inputs.deploy_mode || 'infra-only' }}"
          LAMBDA_AVAILABLE="${{ steps.check-lambda.outputs.available }}"
          APP_AVAILABLE="${{ steps.check-app.outputs.available }}"
          
          if [ "$INPUT_MODE" = "infra-only" ]; then
            echo "mode=infra-only" >> $GITHUB_OUTPUT
            echo "üèóÔ∏è Modo: Apenas infraestrutura"
          elif [ "$INPUT_MODE" = "full-with-fallback" ]; then
            echo "mode=full-with-fallback" >> $GITHUB_OUTPUT
            echo "üöÄ Modo: Deploy completo com fallbacks"
          elif [ "$INPUT_MODE" = "full-with-repos" ] && [ "$LAMBDA_AVAILABLE" = "true" ] && [ "$APP_AVAILABLE" = "true" ]; then
            echo "mode=full-with-repos" >> $GITHUB_OUTPUT
            echo "üíé Modo: Deploy completo com reposit√≥rios reais"
          else
            echo "mode=infra-only" >> $GITHUB_OUTPUT
            echo "‚ö†Ô∏è Fallback para modo: Apenas infraestrutura"
          fi

  create-lambda-package:
    name: 'Criar Pacote Lambda'
    runs-on: ubuntu-latest
    needs: check-repositories
    outputs:
      lambda-created: ${{ steps.create.outcome }}

    steps:
      - name: Criar Lambda simples
        id: create
        run: |
          echo "üì¶ Criando pacote Lambda funcional..."
          
          mkdir lambda-package
          
          # Criar fun√ß√£o Lambda em Node.js
          cat > lambda-package/index.js << 'EOF'
          const mysql = require('mysql2/promise');
          
          exports.handler = async (event) => {
              console.log('Evento recebido:', JSON.stringify(event, null, 2));
              
              const response = {
                  statusCode: 200,
                  headers: {
                      'Content-Type': 'application/json',
                      'Access-Control-Allow-Origin': '*',
                      'Access-Control-Allow-Headers': 'Content-Type',
                      'Access-Control-Allow-Methods': 'GET,POST,PUT,DELETE,OPTIONS'
                  },
                  body: JSON.stringify({
                      message: 'Mana Food API est√° funcionando!',
                      timestamp: new Date().toISOString(),
                      version: '1.0.0',
                      environment: process.env.ASPNETCORE_ENVIRONMENT || 'Production',
                      aurora: {
                          endpoint: process.env.AURORA_ENDPOINT || 'n√£o configurado',
                          database: process.env.DATABASE_NAME || 'appdb'
                      },
                      event: {
                          httpMethod: event.httpMethod,
                          path: event.path,
                          queryStringParameters: event.queryStringParameters
                      }
                  }, null, 2)
              };
              
              // Tratar diferentes rotas
              if (event.path === '/health') {
                  response.body = JSON.stringify({
                      status: 'healthy',
                      service: 'mana-food-lambda',
                      timestamp: new Date().toISOString()
                  });
              }
              
              return response;
          };
          EOF
          
          # Criar package.json
          cat > lambda-package/package.json << 'EOF'
          {
            "name": "mana-food-lambda",
            "version": "1.0.0",
            "description": "Mana Food API Lambda",
            "main": "index.js",
            "dependencies": {
              "mysql2": "^3.6.0"
            }
          }
          EOF
          
          cd lambda-package
          npm install --production
          zip -r ../lambda-deployment.zip .
          
          echo "‚úÖ Lambda package criado:"
          ls -la ../lambda-deployment.zip

      - name: Upload Lambda package
        uses: actions/upload-artifact@v4
        with:
          name: lambda-deployment-${{ github.run_id }}
          path: lambda-deployment.zip
          retention-days: 30

  create-app-image:
    name: 'Criar Imagem da App'
    runs-on: ubuntu-latest
    needs: check-repositories
    if: needs.check-repositories.outputs.deploy-mode != 'infra-only'
    outputs:
      image-tag: ${{ steps.build.outputs.image-tag }}
      image-created: ${{ steps.build.outcome }}

    steps:
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Criar aplica√ß√£o fallback
        run: |
          mkdir -p app-fallback
          
          # Dockerfile para aplica√ß√£o .NET Core simples
          cat > app-fallback/Dockerfile << 'EOF'
          FROM mcr.microsoft.com/dotnet/aspnet:8.0 AS runtime
          WORKDIR /app
          
          # Criar uma aplica√ß√£o .NET m√≠nima
          FROM mcr.microsoft.com/dotnet/sdk:8.0 AS build
          WORKDIR /src
          
          # Criar projeto
          RUN dotnet new web -n ManaFoodApp
          WORKDIR /src/ManaFoodApp
          
          # Modificar Program.cs
          RUN echo 'var builder = WebApplication.CreateBuilder(args);' > Program.cs && \
              echo 'var app = builder.Build();' >> Program.cs && \
              echo '' >> Program.cs && \
              echo 'app.MapGet("/", () => new {' >> Program.cs && \
              echo '    message = "üçΩÔ∏è Mana Food Application",' >> Program.cs && \
              echo '    status = "running",' >> Program.cs && \
              echo '    timestamp = DateTime.UtcNow,' >> Program.cs && \
              echo '    version = "1.0.0",' >> Program.cs && \
              echo '    environment = Environment.GetEnvironmentVariable("ASPNETCORE_ENVIRONMENT") ?? "Production"' >> Program.cs && \
              echo '});' >> Program.cs && \
              echo '' >> Program.cs && \
              echo 'app.MapGet("/health", () => new {' >> Program.cs && \
              echo '    status = "healthy",' >> Program.cs && \
              echo '    service = "mana-food-app",' >> Program.cs && \
              echo '    timestamp = DateTime.UtcNow' >> Program.cs && \
              echo '});' >> Program.cs && \
              echo '' >> Program.cs && \
              echo 'app.MapGet("/health/ready", () => new {' >> Program.cs && \
              echo '    status = "ready",' >> Program.cs && \
              echo '    service = "mana-food-app",' >> Program.cs && \
              echo '    timestamp = DateTime.UtcNow' >> Program.cs && \
              echo '});' >> Program.cs && \
              echo '' >> Program.cs && \
              echo 'app.Run();' >> Program.cs
          
          # Build da aplica√ß√£o
          RUN dotnet publish -c Release -o /app/publish
          
          # Runtime
          FROM runtime
          WORKDIR /app
          COPY --from=build /app/publish .
          
          EXPOSE 8080
          ENV ASPNETCORE_URLS=http://+:8080
          
          ENTRYPOINT ["dotnet", "ManaFoodApp.dll"]
          EOF

      - name: Build e push da imagem
        id: build
        run: |
          cd app-fallback
          
          IMAGE_TAG="ghcr.io/mana-food/mana-food-app-fallback:${GITHUB_SHA:0:8}"
          IMAGE_LATEST="ghcr.io/mana-food/mana-food-app-fallback:latest"
          
          echo "üî® Building imagem Docker..."
          docker build -t "$IMAGE_TAG" -t "$IMAGE_LATEST" .
          
          echo "üì§ Pushing imagem..."
          docker push "$IMAGE_TAG"
          docker push "$IMAGE_LATEST"
          
          echo "image-tag=$IMAGE_TAG" >> $GITHUB_OUTPUT
          echo "‚úÖ Imagem criada: $IMAGE_TAG"

  terraform-deploy:
    name: 'Deploy Infraestrutura'
    runs-on: ubuntu-latest
    needs: [check-repositories, create-lambda-package]
    defaults:
      run:
        working-directory: infra/terraform/envs/prod
    outputs:
      terraform-success: ${{ steps.apply.outcome }}

    steps:
      - name: Checkout c√≥digo
        uses: actions/checkout@v4

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: sa-east-1

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: '1.6.0'
          terraform_wrapper: false

      - name: Terraform Format
        run: terraform fmt -recursive

      - name: Terraform Init
        run: |
          terraform init \
            -backend-config="bucket=${{ secrets.AWS_TF_STATE_BUCKET }}" \
            -backend-config="key=mana-food-prod.tfstate" \
            -backend-config="region=sa-east-1"

      - name: Download Lambda package
        uses: actions/download-artifact@v4
        with:
          name: lambda-deployment-${{ github.run_id }}
          path: infra/terraform/envs/prod

      - name: Verificar Lambda package
        run: |
          if [ -f lambda-deployment.zip ]; then
            echo "‚úÖ Lambda package encontrado"
            ls -la lambda-deployment.zip
            unzip -l lambda-deployment.zip | head -10
          else
            echo "‚ùå Lambda package n√£o encontrado"
            exit 1
          fi

      - name: Terraform Plan
        run: |
          terraform plan \
            -var="bucket_state_name=${{ secrets.AWS_TF_STATE_BUCKET }}" \
            -out=tfplan

      - name: Terraform Apply
        id: apply
        if: github.ref == 'refs/heads/main'
        run: terraform apply -auto-approve tfplan

      - name: Verificar infraestrutura
        run: |
          echo "üîç Verificando infraestrutura criada..."
          
          # EKS
          aws eks describe-cluster --name mana-food-eks --region sa-east-1 --query 'cluster.status'
          
          # Aurora
          aws rds describe-db-clusters --db-cluster-identifier mana-food-aurora --region sa-east-1 --query 'DBClusters[0].Status'
          
          # Lambda
          aws lambda get-function --function-name mana-food-api --region sa-east-1 --query 'Configuration.State'
          
          echo "‚úÖ Infraestrutura verificada"

      - name: Get outputs
        run: |
          terraform output -json > outputs.json
          cat outputs.json

      - name: Upload outputs
        uses: actions/upload-artifact@v4
        with:
          name: terraform-outputs-${{ github.run_id }}
          path: infra/terraform/envs/prod/outputs.json

  deploy-app:
    name: 'Deploy Aplica√ß√£o'
    runs-on: ubuntu-latest
    needs: [terraform-deploy, create-app-image, check-repositories]
    if: needs.terraform-deploy.outputs.terraform-success == 'success' && needs.check-repositories.outputs.deploy-mode != 'infra-only'

    steps:
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: sa-east-1

      - name: Setup kubectl
        uses: azure/setup-kubectl@v3

      - name: Configurar EKS
        run: |
          echo "‚öôÔ∏è Configurando acesso ao EKS..."
          aws eks update-kubeconfig --region sa-east-1 --name mana-food-eks
          
          # Aguardar cluster ficar pronto
          timeout 300 bash -c '
            while ! kubectl cluster-info >/dev/null 2>&1; do
              echo "Aguardando cluster..."
              sleep 15
            done
          '
          
          kubectl get nodes

      - name: Deploy aplica√ß√£o
        run: |
          IMAGE="${{ needs.create-app-image.outputs.image-tag }}"
          
          echo "üöÄ Deployando aplica√ß√£o: $IMAGE"
          
          kubectl apply -f - <<EOF
          apiVersion: v1
          kind: ConfigMap
          metadata:
            name: mana-food-config
            namespace: default
          data:
            ASPNETCORE_ENVIRONMENT: "Production"
            ASPNETCORE_URLS: "http://+:8080"
          ---
          apiVersion: apps/v1
          kind: Deployment
          metadata:
            name: mana-food-app
            namespace: default
          spec:
            replicas: 2
            selector:
              matchLabels:
                app: mana-food-app
            template:
              metadata:
                labels:
                  app: mana-food-app
              spec:
                containers:
                - name: app
                  image: $IMAGE
                  ports:
                  - containerPort: 8080
                  resources:
                    requests:
                      cpu: "100m"
                      memory: "128Mi"
                    limits:
                      cpu: "500m"
                      memory: "512Mi"
                  envFrom:
                  - configMapRef:
                      name: mana-food-config
                  livenessProbe:
                    httpGet:
                      path: /health
                      port: 8080
                    initialDelaySeconds: 30
                    periodSeconds: 30
                  readinessProbe:
                    httpGet:
                      path: /health/ready
                      port: 8080
                    initialDelaySeconds: 15
                    periodSeconds: 10
          ---
          apiVersion: v1
          kind: Service
          metadata:
            name: mana-food-service
            namespace: default
          spec:
            selector:
              app: mana-food-app
            ports:
            - port: 80
              targetPort: 8080
            type: LoadBalancer
          EOF

      - name: Aguardar deployment
        run: |
          echo "‚è≥ Aguardando deployment..."
          kubectl rollout status deployment/mana-food-app --timeout=300s
          
          echo "üìä Status final:"
          kubectl get pods -l app=mana-food-app
          kubectl get svc mana-food-service

  test-deployment:
    name: 'Testar Deployment'
    runs-on: ubuntu-latest
    needs: [terraform-deploy]
    if: needs.terraform-deploy.outputs.terraform-success == 'success'

    steps:
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: sa-east-1

      - name: Testar Lambda
        run: |
          echo "üß™ Testando Lambda..."
          aws lambda invoke \
            --function-name mana-food-api \
            --region sa-east-1 \
            --payload '{"httpMethod":"GET","path":"/health"}' \
            response.json
          
          echo "Resposta da Lambda:"
          cat response.json

      - name: Mostrar URLs
        run: |
          echo "üåê URLs do deployment:"
          
          # API Gateway URL
          API_ID=$(aws apigateway get-rest-apis --region sa-east-1 --query 'items[?name==`mana-food-api`].id' --output text)
          if [ -n "$API_ID" ]; then
            echo "üîó Lambda API: https://$API_ID.execute-api.sa-east-1.amazonaws.com/prod"
          fi
          
          # EKS Service (se existir)
          if aws eks describe-cluster --name mana-food-eks --region sa-east-1 >/dev/null 2>&1; then
            aws eks update-kubeconfig --region sa-east-1 --name mana-food-eks
            kubectl get svc mana-food-service 2>/dev/null || echo "Aplica√ß√£o EKS n√£o deployada"
          fi

  notify-status:
    name: 'Status Final'
    runs-on: ubuntu-latest
    needs: [check-repositories, terraform-deploy, deploy-app, test-deployment]
    if: always()

    steps:
      - name: Resumo do deployment
        run: |
          echo "üìä RESUMO DO DEPLOYMENT MANA FOOD"
          echo "================================="
          echo ""
          echo "üîç Verifica√ß√£o dos reposit√≥rios:"
          echo "  Lambda repo: ${{ needs.check-repositories.outputs.lambda-available }}"
          echo "  App repo: ${{ needs.check-repositories.outputs.app-available }}"
          echo "  Modo deploy: ${{ needs.check-repositories.outputs.deploy-mode }}"
          echo ""
          echo "üèóÔ∏è Infraestrutura:"
          echo "  Terraform: ${{ needs.terraform-deploy.result }}"
          echo ""
          echo "üöÄ Aplica√ß√£o:"
          echo "  Deploy app: ${{ needs.deploy-app.result }}"
          echo ""
          echo "üß™ Testes:"
          echo "  Testes: ${{ needs.test-deployment.result }}"
          echo ""
          
          if [ "${{ needs.terraform-deploy.result }}" = "success" ]; then
            echo "‚úÖ INFRAESTRUTURA CRIADA COM SUCESSO!"
            echo ""
            echo "üéØ Recursos criados:"
            echo "  - EKS Cluster: mana-food-eks"
            echo "  - Aurora MySQL: mana-food-aurora"
            echo "  - Lambda Function: mana-food-api"
            echo "  - VPC e Networking completo"
            echo ""
            echo "üîó Pr√≥ximos passos:"
            echo "  1. Verificar URLs no job 'test-deployment'"
            echo "  2. Configurar reposit√≥rios de c√≥digo se necess√°rio"
            echo "  3. Re-executar com modo 'full-with-repos' quando pronto"
          else
            echo "‚ùå FALHA NO DEPLOYMENT"
            echo "Verifique os logs dos jobs para mais detalhes"
          fi