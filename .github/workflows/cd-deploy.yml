name: Deploy Mana Food - Simples com Rollback

on:
  workflow_dispatch:
    inputs:
      deploy_mode:
        description: "Modo de deploy"
        type: choice
        options:
          - "full-deploy"
          - "infra-only"
          - "lambda-only"
        default: "full-deploy"
  push:
    branches:
      - main

permissions:
  contents: read
  packages: write
  id-token: write

jobs:
  build-lambda:
    name: 'Build Lambda'
    runs-on: ubuntu-latest
    outputs:
      lambda-success: ${{ steps.build.outcome }}

    steps:
      - name: Checkout Lambda repo
        uses: actions/checkout@v4
        with:
          repository: mana-food/mana-food-lambda
          token: ${{ secrets.PERSONAL_ACCESS_TOKEN_MANA_FOOD_APP }}
          path: lambda-repo

      - name: Setup .NET 9
        uses: actions/setup-dotnet@v3
        with:
          dotnet-version: '9.0.x'

      - name: Build Lambda
        id: build
        run: |
          cd lambda-repo
          SLN_FILE=$(find . -name "*.sln" | head -1)
          
          if [ -n "$SLN_FILE" ]; then
            dotnet restore "$SLN_FILE"
            dotnet build --configuration Release "$SLN_FILE"
            
            LAMBDA_PROJ=$(find . -name "*Lambda*.csproj" -o -name "*Auth*.csproj" | head -1)
            dotnet publish "$LAMBDA_PROJ" --configuration Release --runtime linux-x64 -o publish/
            
            cd publish
            zip -r ../../lambda-deployment.zip .
          else
            echo "Solution não encontrada"
            exit 1
          fi

      - name: Upload Lambda
        uses: actions/upload-artifact@v4
        with:
          name: lambda-deployment-${{ github.run_id }}
          path: lambda-deployment.zip

  build-app:
    name: 'Build App'
    runs-on: ubuntu-latest
    if: github.event.inputs.deploy_mode != 'lambda-only'
    outputs:
      image-tag: ${{ steps.build.outputs.image-tag }}

    steps:
      - name: Checkout App repo
        uses: actions/checkout@v4
        with:
          repository: mana-food/mana-food-clean-architecture
          token: ${{ secrets.PERSONAL_ACCESS_TOKEN_MANA_FOOD_APP }}
          path: app-repo

      - name: Setup Docker
        uses: docker/setup-buildx-action@v3

      - name: Login GitHub Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.PERSONAL_ACCESS_TOKEN_MANA_FOOD_APP }}

      - name: Build Image
        id: build
        run: |
          cd app-repo
          
          if [ -f Dockerfile ]; then
            IMAGE_TAG="ghcr.io/mana-food/mana-food-app:${GITHUB_SHA:0:8}"
            docker build -t "$IMAGE_TAG" .
            docker push "$IMAGE_TAG"
            echo "image-tag=$IMAGE_TAG" >> $GITHUB_OUTPUT
          else
            echo "FROM nginx:alpine
            RUN echo '<h1>Mana Food</h1><p>Lambda Auth funcionando!</p>' > /usr/share/nginx/html/index.html" > Dockerfile
            
            IMAGE_TAG="ghcr.io/mana-food/mana-food-placeholder:${GITHUB_SHA:0:8}"
            docker build -t "$IMAGE_TAG" .
            docker push "$IMAGE_TAG"
            echo "image-tag=$IMAGE_TAG" >> $GITHUB_OUTPUT
          fi

  terraform-deploy:
    name: 'Deploy Infra'
    runs-on: ubuntu-latest
    needs: build-lambda
    defaults:
      run:
        working-directory: infra/terraform/envs/prod
    outputs:
      terraform-success: ${{ steps.apply.outcome }}
      aurora-endpoint: ${{ steps.outputs.outputs.aurora-endpoint }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Configure AWS
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: sa-east-1

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: '1.6.0'
          terraform_wrapper: false

      - name: Download Lambda
        uses: actions/download-artifact@v4
        with:
          name: lambda-deployment-${{ github.run_id }}
          path: infra/terraform/envs/prod

      - name: Fix AWS_REGION in lambda.tf
        run: |
          # Remover AWS_REGION das variáveis de ambiente da Lambda
          if grep -q "AWS_REGION" lambda.tf; then
            sed -i '/AWS_REGION.*= var.aws_region/d' lambda.tf
            echo "AWS_REGION removido de lambda.tf"
          fi
          
          # Verificar arquivo
          echo "Conteúdo do bloco environment:"
          grep -A 10 "environment" lambda.tf || true

      - name: Terraform Init
        run: |
          terraform init \
            -backend-config="bucket=${{ secrets.AWS_TF_STATE_BUCKET }}" \
            -backend-config="key=mana-food-prod.tfstate" \
            -backend-config="region=sa-east-1"

      - name: Terraform Apply
        id: apply
        run: |
          terraform plan -var="bucket_state_name=${{ secrets.AWS_TF_STATE_BUCKET }}" -out=tfplan
          terraform apply -auto-approve tfplan

      - name: Get Outputs
        id: outputs
        if: steps.apply.outcome == 'success'
        run: |
          AURORA_ENDPOINT=$(terraform output -raw aurora_endpoint)
          echo "aurora-endpoint=$AURORA_ENDPOINT" >> $GITHUB_OUTPUT

  setup-database:
    name: 'Setup DB'
    runs-on: ubuntu-latest
    needs: terraform-deploy
    if: needs.terraform-deploy.outputs.terraform-success == 'success'

    steps:
      - name: Configure AWS
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: sa-east-1

      - name: Wait for Aurora to be available
        run: |
          AURORA_ENDPOINT="${{ needs.terraform-deploy.outputs.aurora-endpoint }}"
          echo "Aguardando Aurora estar disponível em: $AURORA_ENDPOINT"
          
          # Aguardar até 15 minutos pelo Aurora
          TIMEOUT=900  # 15 minutos
          ELAPSED=0
          SLEEP_TIME=30
          
          while [ $ELAPSED -lt $TIMEOUT ]; do
            echo "Tentativa $((ELAPSED/SLEEP_TIME + 1)) - Verificando Aurora... (${ELAPSED}s/${TIMEOUT}s)"
            
            if nc -z -w5 $AURORA_ENDPOINT 3306; then
              echo "✅ Aurora está respondendo!"
              break
            fi
            
            # Verificar status via AWS CLI
            STATUS=$(aws rds describe-db-clusters --db-cluster-identifier mana-food-aurora --region sa-east-1 --query 'DBClusters[0].Status' --output text 2>/dev/null || echo "unknown")
            echo "Status Aurora: $STATUS"
            
            if [ "$STATUS" = "available" ]; then
              echo "✅ Aurora está disponível pelo AWS CLI!"
              # Aguardar mais um pouco para garantir conectividade
              sleep 60
              break
            fi
            
            sleep $SLEEP_TIME
            ELAPSED=$((ELAPSED + SLEEP_TIME))
          done
          
          if [ $ELAPSED -ge $TIMEOUT ]; then
            echo "❌ Timeout aguardando Aurora"
            exit 1
          fi

      - name: Setup Database
        run: |
          AURORA_ENDPOINT="${{ needs.terraform-deploy.outputs.aurora-endpoint }}"
          DB_PASSWORD="${{ secrets.DB_PASSWORD || 'TempPassword123!' }}"
          
          echo "Configurando banco de dados..."
          
          # Tentar conectar com retry
          for i in {1..5}; do
            echo "Tentativa $i de configuração do banco..."
            
            if docker run --rm mysql:8.0 mysql \
              -h "$AURORA_ENDPOINT" \
              -u admin \
              -p"$DB_PASSWORD" \
              --connect-timeout=60 \
              -e "
              CREATE DATABASE IF NOT EXISTS appdb;
              USE appdb;
              CREATE TABLE IF NOT EXISTS users (
                  id CHAR(36) PRIMARY KEY DEFAULT (UUID()),
                  cpf VARCHAR(11) NOT NULL UNIQUE,
                  name VARCHAR(255),
                  email VARCHAR(255),
                  user_type INT DEFAULT 1,
                  deleted BOOLEAN DEFAULT FALSE,
                  INDEX idx_cpf (cpf)
              );
              INSERT IGNORE INTO users (cpf, name, email) VALUES 
              ('12345678901', 'Cliente Teste', 'teste@test.com'),
              ('98765432100', 'Admin Teste', 'admin@test.com');
              SELECT COUNT(*) as total_users FROM users;
              "; then
              echo "✅ Banco configurado com sucesso!"
              break
            else
              echo "❌ Falha na tentativa $i"
              if [ $i -eq 5 ]; then
                echo "❌ Falha após 5 tentativas"
                exit 1
              fi
              sleep 30
            fi
          done

  configure-lambda:
    name: 'Config Lambda'
    runs-on: ubuntu-latest
    needs: [terraform-deploy, setup-database]

    steps:
      - name: Configure AWS
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: sa-east-1

      - name: Update Lambda
        run: |
          AURORA_ENDPOINT="${{ needs.terraform-deploy.outputs.aurora-endpoint }}"
          CONNECTION_STRING="Server=$AURORA_ENDPOINT;Port=3306;Database=appdb;Uid=admin;Pwd=${{ secrets.DB_PASSWORD || 'TempPassword123!' }};SslMode=Required;"
          
          # Configurar apenas variáveis não-reservadas
          aws lambda update-function-configuration \
            --function-name mana-food-api \
            --region sa-east-1 \
            --environment Variables="{
              \"MYSQL_CONNECTION_STRING\":\"$CONNECTION_STRING\",
              \"ASPNETCORE_ENVIRONMENT\":\"Production\",
              \"AURORA_ENDPOINT\":\"$AURORA_ENDPOINT\",
              \"DATABASE_NAME\":\"appdb\"
            }"
          
          # Aguardar atualização
          aws lambda wait function-updated --function-name mana-food-api --region sa-east-1

  test-lambda:
    name: 'Test Auth'
    runs-on: ubuntu-latest
    needs: configure-lambda

    steps:
      - name: Configure AWS
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: sa-east-1

      - name: Test Lambda
        run: |
          # Teste direto
          echo "Testando Lambda diretamente..."
          aws lambda invoke --function-name mana-food-api --payload '{"cpf":"12345678901"}' response.json
          cat response.json
          
          # Teste API Gateway
          echo "Testando via API Gateway..."
          API_ID=$(aws apigateway get-rest-apis --query 'items[?name==`mana-food-api`].id' --output text)
          if [ "$API_ID" != "None" ] && [ -n "$API_ID" ]; then
            API_URL="https://$API_ID.execute-api.sa-east-1.amazonaws.com/prod"
            echo "API URL: $API_URL"
            
            curl -X POST "$API_URL" -H "Content-Type: application/json" -d '{"cpf":"12345678901"}' || echo "Falha no teste API Gateway"
          else
            echo "API Gateway não encontrado"
          fi

  deploy-app:
    name: 'Deploy App'
    runs-on: ubuntu-latest
    needs: [terraform-deploy, build-app, test-lambda]
    if: github.event.inputs.deploy_mode != 'lambda-only'

    steps:
      - name: Configure AWS
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: sa-east-1

      - name: Setup kubectl
        uses: azure/setup-kubectl@v3

      - name: Deploy to EKS
        run: |
          aws eks update-kubeconfig --region sa-east-1 --name mana-food-eks
          
          IMAGE="${{ needs.build-app.outputs.image-tag || 'nginx:latest' }}"
          API_ID=$(aws apigateway get-rest-apis --query 'items[?name==`mana-food-api`].id' --output text)
          API_URL="https://$API_ID.execute-api.sa-east-1.amazonaws.com/prod"
          
          kubectl apply -f - <<EOF
          apiVersion: apps/v1
          kind: Deployment
          metadata:
            name: mana-food-app
          spec:
            replicas: 2
            selector:
              matchLabels:
                app: mana-food-app
            template:
              metadata:
                labels:
                  app: mana-food-app
              spec:
                containers:
                - name: app
                  image: $IMAGE
                  ports:
                  - containerPort: 80
                  env:
                  - name: AUTH_API_URL
                    value: "$API_URL"
          ---
          apiVersion: v1
          kind: Service
          metadata:
            name: mana-food-service
          spec:
            selector:
              app: mana-food-app
            ports:
            - port: 80
              targetPort: 80
            type: LoadBalancer
          EOF
          
          kubectl rollout status deployment/mana-food-app --timeout=300s
          kubectl get svc mana-food-service

  rollback:
    name: 'Rollback'
    runs-on: ubuntu-latest
    needs: [terraform-deploy, setup-database, configure-lambda, test-lambda, deploy-app]
    if: failure() && (needs.terraform-deploy.result == 'success')
    defaults:
      run:
        working-directory: infra/terraform/envs/prod

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Configure AWS
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: sa-east-1

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: '1.6.0'
          terraform_wrapper: false

      - name: Download Lambda (for state)
        uses: actions/download-artifact@v4
        with:
          name: lambda-deployment-${{ github.run_id }}
          path: infra/terraform/envs/prod
        continue-on-error: true

      - name: Terraform Init
        run: |
          terraform init \
            -backend-config="bucket=${{ secrets.AWS_TF_STATE_BUCKET }}" \
            -backend-config="key=mana-food-prod.tfstate" \
            -backend-config="region=sa-east-1"

      - name: Cleanup EKS Apps
        run: |
          aws eks update-kubeconfig --region sa-east-1 --name mana-food-eks || true
          kubectl delete deployment mana-food-app || true
          kubectl delete service mana-food-service || true
        continue-on-error: true

      - name: Terraform Destroy
        run: |
          echo "🚨 Executando rollback - destruindo infraestrutura..."
          terraform destroy -var="bucket_state_name=${{ secrets.AWS_TF_STATE_BUCKET }}" -auto-approve
        continue-on-error: true

      - name: Manual Cleanup
        run: |
          echo "🧹 Limpeza manual de recursos órfãos..."
          
          # Cleanup Lambda
          aws lambda delete-function --function-name mana-food-api || true
          
          # Cleanup API Gateway
          API_ID=$(aws apigateway get-rest-apis --query 'items[?name==`mana-food-api`].id' --output text)
          if [ "$API_ID" != "None" ]; then
            aws apigateway delete-rest-api --rest-api-id "$API_ID" || true
          fi
          
          # Cleanup Log Groups
          aws logs delete-log-group --log-group-name "/aws/lambda/mana-food-api" || true
          aws logs delete-log-group --log-group-name "/aws/eks/mana-food-eks/cluster" || true
          
          echo "✅ Rollback concluído"

  status:
    name: 'Status'
    runs-on: ubuntu-latest
    needs: [terraform-deploy, test-lambda, deploy-app, rollback]
    if: always()

    steps:
      - name: Report
        run: |
          echo "🎯 MANA FOOD DEPLOYMENT"
          echo "======================="
          echo "Infraestrutura: ${{ needs.terraform-deploy.result }}"
          echo "Auth Lambda: ${{ needs.test-lambda.result }}"
          echo "App EKS: ${{ needs.deploy-app.result }}"
          echo "Rollback: ${{ needs.rollback.result }}"
          echo ""
          
          if [ "${{ needs.rollback.result }}" = "success" ]; then
            echo "🚨 ROLLBACK EXECUTADO - Infraestrutura removida"
          elif [ "${{ needs.terraform-deploy.result }}" = "success" ]; then
            echo "✅ Sistema deployado!"
            echo "🔑 CPFs de teste: 12345678901, 98765432100"
          else
            echo "❌ Falha no deployment"
          fi