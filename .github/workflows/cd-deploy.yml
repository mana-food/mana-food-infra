name: Deploy Mana Food - Lambda Real

on:
  workflow_dispatch:
    inputs:
      deploy_mode:
        description: "Modo de deploy"
        type: choice
        options:
          - "full-deploy"
          - "infra-only"
          - "lambda-only"
        default: "full-deploy"
      lambda_ref:
        description: "Branch/Tag da Lambda"
        default: "main"
      app_ref:
        description: "Branch/Tag da App"
        default: "main"
  push:
    branches:
      - main

permissions:
  contents: read
  packages: write
  id-token: write

jobs:
  build-lambda:
    name: 'Build Lambda Real'
    runs-on: ubuntu-latest
    outputs:
      lambda-success: ${{ steps.build.outcome }}

    steps:
      - name: Checkout repositÃ³rio da Lambda
        uses: actions/checkout@v4
        with:
          repository: mana-food/mana-food-lambda
          ref: ${{ github.event.inputs.lambda_ref || 'main' }}
          token: ${{ secrets.GITHUB_TOKEN }}
          path: lambda-repo

      - name: Setup .NET 9
        uses: actions/setup-dotnet@v3
        with:
          dotnet-version: '9.0.x'
          include-prerelease: true

      - name: Verificar estrutura Lambda
        run: |
          echo "ğŸ“ Verificando estrutura do repositÃ³rio Lambda..."
          ls -la lambda-repo/
          find lambda-repo -name "*.csproj" -type f

      - name: Restore dependencies
        run: |
          cd lambda-repo/src/ManaFood.AuthLambda
          dotnet restore

      - name: Build Lambda
        id: build
        run: |
          cd lambda-repo/src/ManaFood.AuthLambda
          
          echo "ğŸ”¨ Building Lambda project..."
          dotnet build --configuration Release --no-restore
          
          echo "ğŸ“¦ Publishing Lambda..."
          dotnet publish --configuration Release --runtime linux-x64 --self-contained false -o publish/
          
          echo "âœ… Build concluÃ­do"
          ls -la publish/

      - name: Create Lambda ZIP
        run: |
          cd lambda-repo/src/ManaFood.AuthLambda/publish
          
          echo "ğŸ“¦ Criando ZIP para Lambda..."
          zip -r ../../../../../lambda-deployment.zip .
          
          echo "âœ… ZIP criado:"
          ls -la ../../../../../lambda-deployment.zip

      - name: Upload Lambda artifact
        uses: actions/upload-artifact@v4
        with:
          name: lambda-deployment-${{ github.run_id }}
          path: lambda-deployment.zip
          retention-days: 30

  build-app-image:
    name: 'Build App do RepositÃ³rio'
    runs-on: ubuntu-latest
    if: github.event.inputs.deploy_mode != 'lambda-only'
    outputs:
      image-tag: ${{ steps.build.outputs.image-tag }}
      build-success: ${{ steps.build.outcome }}

    steps:
      - name: Checkout repositÃ³rio da App
        uses: actions/checkout@v4
        with:
          repository: mana-food/mana-food-clean-architecture
          ref: ${{ github.event.inputs.app_ref || 'main' }}
          token: ${{ secrets.GITHUB_TOKEN }}
          path: app-repo

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Verificar estrutura da App
        run: |
          echo "ğŸ“ Verificando estrutura do repositÃ³rio da App..."
          ls -la app-repo/
          find app-repo -name "Dockerfile" -type f || echo "Dockerfile nÃ£o encontrado"

      - name: Build e push da imagem
        id: build
        run: |
          cd app-repo
          
          if [ -f Dockerfile ]; then
            echo "ğŸ”¨ Dockerfile encontrado, fazendo build..."
            
            IMAGE_TAG="ghcr.io/mana-food/mana-food-clean-architecture:${GITHUB_SHA:0:8}"
            IMAGE_LATEST="ghcr.io/mana-food/mana-food-clean-architecture:latest"
            
            docker build -t "$IMAGE_TAG" -t "$IMAGE_LATEST" .
            docker push "$IMAGE_TAG"
            docker push "$IMAGE_LATEST"
            
            echo "image-tag=$IMAGE_TAG" >> $GITHUB_OUTPUT
            echo "âœ… Imagem criada: $IMAGE_TAG"
          else
            echo "âš ï¸ Dockerfile nÃ£o encontrado, criando placeholder..."
            
            # Criar Dockerfile placeholder
            cat > Dockerfile << 'EOF'
          FROM nginx:alpine
          RUN echo '<html><body><h1>ğŸ½ï¸ Mana Food App</h1><p>Placeholder - Lambda funcionando!</p></body></html>' > /usr/share/nginx/html/index.html
          EXPOSE 80
          EOF
            
            IMAGE_TAG="ghcr.io/mana-food/mana-food-placeholder:${GITHUB_SHA:0:8}"
            
            docker build -t "$IMAGE_TAG" .
            docker push "$IMAGE_TAG"
            
            echo "image-tag=$IMAGE_TAG" >> $GITHUB_OUTPUT
            echo "âœ… Imagem placeholder criada: $IMAGE_TAG"
          fi

  terraform-deploy:
    name: 'Deploy Infraestrutura'
    runs-on: ubuntu-latest
    needs: build-lambda
    defaults:
      run:
        working-directory: infra/terraform/envs/prod
    outputs:
      terraform-success: ${{ steps.apply.outcome }}
      aurora-endpoint: ${{ steps.outputs.outputs.aurora-endpoint }}
      aurora-secret-arn: ${{ steps.outputs.outputs.aurora-secret-arn }}

    steps:
      - name: Checkout repositÃ³rio de infraestrutura
        uses: actions/checkout@v4

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: sa-east-1

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: '1.6.0'
          terraform_wrapper: false

      - name: Terraform Format
        run: terraform fmt -recursive

      - name: Terraform Init
        run: |
          terraform init \
            -backend-config="bucket=${{ secrets.AWS_TF_STATE_BUCKET }}" \
            -backend-config="key=mana-food-prod.tfstate" \
            -backend-config="region=sa-east-1"

      - name: Download Lambda ZIP
        uses: actions/download-artifact@v4
        with:
          name: lambda-deployment-${{ github.run_id }}
          path: infra/terraform/envs/prod

      - name: Verificar Lambda ZIP
        run: |
          if [ -f lambda-deployment.zip ]; then
            echo "âœ… Lambda ZIP encontrado"
            ls -la lambda-deployment.zip
            unzip -l lambda-deployment.zip | head -20
          else
            echo "âŒ Lambda ZIP nÃ£o encontrado"
            exit 1
          fi

      - name: Terraform Plan
        run: |
          terraform plan \
            -var="bucket_state_name=${{ secrets.AWS_TF_STATE_BUCKET }}" \
            -out=tfplan

      - name: Terraform Apply
        id: apply
        if: github.ref == 'refs/heads/main'
        run: terraform apply -auto-approve tfplan

      - name: Get Terraform Outputs
        id: outputs
        if: steps.apply.outcome == 'success'
        run: |
          terraform output -json > outputs.json
          cat outputs.json
          
          # Extrair outputs especÃ­ficos
          AURORA_ENDPOINT=$(terraform output -raw aurora_endpoint)
          echo "aurora-endpoint=$AURORA_ENDPOINT" >> $GITHUB_OUTPUT
          
          # Tentar obter o ARN do secret
          SECRET_ARN=$(aws rds describe-db-clusters --db-cluster-identifier mana-food-aurora --region sa-east-1 --query 'DBClusters[0].MasterUserSecret.SecretArn' --output text 2>/dev/null || echo "None")
          echo "aurora-secret-arn=$SECRET_ARN" >> $GITHUB_OUTPUT

      - name: Verificar infraestrutura
        run: |
          echo "ğŸ” Verificando infraestrutura criada..."
          
          # EKS
          aws eks describe-cluster --name mana-food-eks --region sa-east-1 --query 'cluster.status'
          
          # Aurora
          aws rds describe-db-clusters --db-cluster-identifier mana-food-aurora --region sa-east-1 --query 'DBClusters[0].Status'
          
          # Lambda
          aws lambda get-function --function-name mana-food-api --region sa-east-1 --query 'Configuration.State'

      - name: Upload outputs
        uses: actions/upload-artifact@v4
        with:
          name: terraform-outputs-${{ github.run_id }}
          path: infra/terraform/envs/prod/outputs.json

  setup-database:
    name: 'Setup Database'
    runs-on: ubuntu-latest
    needs: terraform-deploy
    if: needs.terraform-deploy.outputs.terraform-success == 'success'

    steps:
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: sa-east-1

      - name: Get Aurora credentials
        id: aurora-creds
        run: |
          SECRET_ARN="${{ needs.terraform-deploy.outputs.aurora-secret-arn }}"
          
          if [ "$SECRET_ARN" != "None" ] && [ "$SECRET_ARN" != "null" ] && [ -n "$SECRET_ARN" ]; then
            echo "ğŸ” Obtendo credenciais do Secrets Manager..."
            SECRET_VALUE=$(aws secretsmanager get-secret-value --secret-id "$SECRET_ARN" --region sa-east-1 --query 'SecretString' --output text)
            DB_PASSWORD=$(echo "$SECRET_VALUE" | jq -r '.password')
            DB_USERNAME=$(echo "$SECRET_VALUE" | jq -r '.username')
            
            echo "aurora-username=$DB_USERNAME" >> $GITHUB_OUTPUT
            echo "aurora-password=$DB_PASSWORD" >> $GITHUB_OUTPUT
          else
            echo "âš ï¸ Usando credenciais padrÃ£o"
            echo "aurora-username=admin" >> $GITHUB_OUTPUT
            echo "aurora-password=${{ secrets.DB_PASSWORD || 'TempPassword123!' }}" >> $GITHUB_OUTPUT
          fi

      - name: Wait for Aurora and create schema
        run: |
          AURORA_ENDPOINT="${{ needs.terraform-deploy.outputs.aurora-endpoint }}"
          DB_USERNAME="${{ steps.aurora-creds.outputs.aurora-username }}"
          DB_PASSWORD="${{ steps.aurora-creds.outputs.aurora-password }}"
          
          echo "ğŸ—„ï¸ Configurando banco de dados..."
          
          # Aguardar Aurora estar disponÃ­vel
          echo "â³ Aguardando Aurora estar disponÃ­vel..."
          timeout 600 bash -c "
            while ! nc -z $AURORA_ENDPOINT 3306; do
              echo 'Aguardando Aurora... $(date)'
              sleep 30
            done
          "
          
          # Criar e executar script SQL
          cat > setup_db.sql << 'EOF'
          CREATE DATABASE IF NOT EXISTS appdb;
          USE appdb;
          
          CREATE TABLE IF NOT EXISTS users (
              id CHAR(36) PRIMARY KEY DEFAULT (UUID()),
              cpf VARCHAR(11) NOT NULL UNIQUE,
              name VARCHAR(255),
              email VARCHAR(255),
              created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
              deleted BOOLEAN DEFAULT FALSE,
              user_type INT DEFAULT 1,
              INDEX idx_cpf (cpf),
              INDEX idx_deleted (deleted)
          );
          
          INSERT IGNORE INTO users (id, cpf, name, email, user_type, deleted) VALUES 
          (UUID(), '12345678901', 'Cliente Teste', 'cliente@test.com', 1, FALSE),
          (UUID(), '98765432100', 'Admin Teste', 'admin@test.com', 2, FALSE),
          (UUID(), '11111111111', 'User Mana Food', 'user@manafood.com', 1, FALSE);
          
          SELECT COUNT(*) as total_users FROM users WHERE deleted = FALSE;
          EOF
          
          # Executar SQL
          docker run --rm mysql:8.0 mysql \
            -h "$AURORA_ENDPOINT" \
            -u "$DB_USERNAME" \
            -p"$DB_PASSWORD" \
            -e "$(cat setup_db.sql)"
          
          echo "âœ… Banco de dados configurado"

  update-lambda-config:
    name: 'Configurar Lambda'
    runs-on: ubuntu-latest
    needs: [terraform-deploy, setup-database]
    if: needs.terraform-deploy.outputs.terraform-success == 'success'

    steps:
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: sa-east-1

      - name: Get Aurora credentials
        id: aurora-creds
        run: |
          SECRET_ARN="${{ needs.terraform-deploy.outputs.aurora-secret-arn }}"
          
          if [ "$SECRET_ARN" != "None" ] && [ "$SECRET_ARN" != "null" ] && [ -n "$SECRET_ARN" ]; then
            SECRET_VALUE=$(aws secretsmanager get-secret-value --secret-id "$SECRET_ARN" --region sa-east-1 --query 'SecretString' --output text)
            DB_PASSWORD=$(echo "$SECRET_VALUE" | jq -r '.password')
            DB_USERNAME=$(echo "$SECRET_VALUE" | jq -r '.username')
          else
            DB_USERNAME="admin"
            DB_PASSWORD="${{ secrets.DB_PASSWORD || 'TempPassword123!' }}"
          fi
          
          echo "aurora-username=$DB_USERNAME" >> $GITHUB_OUTPUT
          echo "aurora-password=$DB_PASSWORD" >> $GITHUB_OUTPUT

      - name: Update Lambda environment variables
        run: |
          AURORA_ENDPOINT="${{ needs.terraform-deploy.outputs.aurora-endpoint }}"
          DB_USERNAME="${{ steps.aurora-creds.outputs.aurora-username }}"
          DB_PASSWORD="${{ steps.aurora-creds.outputs.aurora-password }}"
          
          # Criar connection string
          CONNECTION_STRING="Server=$AURORA_ENDPOINT;Port=3306;Database=appdb;Uid=$DB_USERNAME;Pwd=$DB_PASSWORD;SslMode=Required;"
          
          echo "ğŸ”§ Atualizando variÃ¡veis da Lambda..."
          
          # A Lambda real sÃ³ precisa da connection string
          aws lambda update-function-configuration \
            --function-name mana-food-api \
            --region sa-east-1 \
            --environment Variables="{
              \"MYSQL_CONNECTION_STRING\":\"$CONNECTION_STRING\",
              \"ASPNETCORE_ENVIRONMENT\":\"Production\"
            }"
          
          echo "âœ… Lambda configurada com sucesso"

  test-lambda:
    name: 'Testar Lambda'
    runs-on: ubuntu-latest
    needs: [terraform-deploy, update-lambda-config]
    if: needs.terraform-deploy.outputs.terraform-success == 'success'

    steps:
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: sa-east-1

      - name: Test Lambda authentication
        run: |
          echo "ğŸ§ª Testando Lambda de autenticaÃ§Ã£o..."
          
          # Teste 1: AutenticaÃ§Ã£o com CPF vÃ¡lido
          echo "1. Testando autenticaÃ§Ã£o com CPF vÃ¡lido..."
          aws lambda invoke \
            --function-name mana-food-api \
            --region sa-east-1 \
            --payload '{"cpf":"12345678901"}' \
            response_auth.json
          
          echo "Resposta autenticaÃ§Ã£o:"
          cat response_auth.json
          echo ""
          
          # Verificar se retornou token
          if cat response_auth.json | jq -r '.body' | jq -r '.token' | grep -q "eyJ"; then
            echo "âœ… Token JWT gerado com sucesso"
          else
            echo "âŒ Token nÃ£o gerado - verificando estrutura da resposta"
            cat response_auth.json | jq '.'
          fi
          
          # Teste 2: CPF invÃ¡lido
          echo "2. Testando CPF invÃ¡lido..."
          aws lambda invoke \
            --function-name mana-food-api \
            --region sa-east-1 \
            --payload '{"cpf":"00000000000"}' \
            response_invalid.json
          
          echo "Resposta CPF invÃ¡lido:"
          cat response_invalid.json
          echo ""
          
          # Teste 3: Request sem CPF
          echo "3. Testando request sem CPF..."
          aws lambda invoke \
            --function-name mana-food-api \
            --region sa-east-1 \
            --payload '{}' \
            response_empty.json
          
          echo "Resposta sem CPF:"
          cat response_empty.json

      - name: Get API Gateway URL
        run: |
          echo "ğŸŒ URLs da API:"
          
          # Obter API Gateway URL
          API_ID=$(aws apigateway get-rest-apis --region sa-east-1 --query 'items[?name==`mana-food-api`].id' --output text)
          if [ -n "$API_ID" ] && [ "$API_ID" != "None" ]; then
            API_URL="https://$API_ID.execute-api.sa-east-1.amazonaws.com/prod"
            echo "ğŸ”— Lambda Auth API: $API_URL"
            
            # Testar via API Gateway
            echo "ğŸ§ª Testando via API Gateway..."
            curl -X POST \
              "$API_URL" \
              -H "Content-Type: application/json" \
              -d '{"cpf":"12345678901"}' \
              -w "\nStatus: %{http_code}\n" || echo "âš ï¸ Falha no teste via API Gateway"
          else
            echo "âš ï¸ API Gateway nÃ£o encontrado ou nÃ£o configurado"
          fi

  deploy-app:
    name: 'Deploy App to EKS'
    runs-on: ubuntu-latest
    needs: [terraform-deploy, build-app-image]
    if: needs.terraform-deploy.outputs.terraform-success == 'success' && github.event.inputs.deploy_mode != 'lambda-only'

    steps:
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: sa-east-1

      - name: Setup kubectl
        uses: azure/setup-kubectl@v3

      - name: Configure EKS
        run: |
          echo "âš™ï¸ Configurando acesso ao EKS..."
          aws eks update-kubeconfig --region sa-east-1 --name mana-food-eks
          
          # Aguardar cluster
          timeout 300 bash -c '
            while ! kubectl cluster-info >/dev/null 2>&1; do
              echo "Aguardando cluster..."
              sleep 15
            done
          '
          
          kubectl get nodes

      - name: Deploy application
        run: |
          IMAGE="${{ needs.build-app-image.outputs.image-tag || 'nginx:latest' }}"
          API_ID=$(aws apigateway get-rest-apis --region sa-east-1 --query 'items[?name==`mana-food-api`].id' --output text)
          API_URL="https://$API_ID.execute-api.sa-east-1.amazonaws.com/prod"
          
          echo "ğŸš€ Deployando aplicaÃ§Ã£o: $IMAGE"
          echo "ğŸ”— Auth API: $API_URL"
          
          kubectl apply -f - <<EOF
          apiVersion: v1
          kind: ConfigMap
          metadata:
            name: mana-food-config
            namespace: default
          data:
            ASPNETCORE_ENVIRONMENT: "Production"
            AUTH_API_URL: "$API_URL"
          ---
          apiVersion: apps/v1
          kind: Deployment
          metadata:
            name: mana-food-app
            namespace: default
          spec:
            replicas: 2
            selector:
              matchLabels:
                app: mana-food-app
            template:
              metadata:
                labels:
                  app: mana-food-app
              spec:
                containers:
                - name: app
                  image: $IMAGE
                  ports:
                  - containerPort: 80
                  resources:
                    requests:
                      cpu: "100m"
                      memory: "128Mi"
                    limits:
                      cpu: "500m"
                      memory: "512Mi"
                  envFrom:
                  - configMapRef:
                      name: mana-food-config
          ---
          apiVersion: v1
          kind: Service
          metadata:
            name: mana-food-service
            namespace: default
          spec:
            selector:
              app: mana-food-app
            ports:
            - port: 80
              targetPort: 80
            type: LoadBalancer
          EOF

      - name: Check deployment
        run: |
          kubectl rollout status deployment/mana-food-app --timeout=300s
          kubectl get pods -l app=mana-food-app
          kubectl get svc mana-food-service

  notify-status:
    name: 'Status Final'
    runs-on: ubuntu-latest
    needs: [terraform-deploy, test-lambda, deploy-app]
    if: always()

    steps:
      - name: Resumo final
        run: |
          echo "ğŸ¯ RESUMO DO DEPLOYMENT MANA FOOD"
          echo "=================================="
          echo "ğŸ“¦ RepositÃ³rios utilizados:"
          echo "  - Infra: mana-food/mana-food-infra"
          echo "  - Lambda: mana-food/mana-food-lambda"
          echo "  - App: mana-food/mana-food-clean-architecture"
          echo ""
          echo "ğŸ—ï¸ Infraestrutura: ${{ needs.terraform-deploy.result }}"
          echo "ğŸ”§ Lambda Auth: ${{ needs.test-lambda.result }}"
          echo "ğŸš€ App EKS: ${{ needs.deploy-app.result }}"
          echo ""
          
          if [ "${{ needs.terraform-deploy.result }}" = "success" ]; then
            echo "âœ… DEPLOYMENT REALIZADO COM SUCESSO!"
            echo ""
            echo "ğŸ¯ Sistema funcionando:"
            echo "  - ğŸ—„ï¸  Aurora MySQL com dados de teste"
            echo "  - âš¡ Lambda Auth (.NET 9) funcionando"
            echo "  - ğŸŒ API Gateway para autenticaÃ§Ã£o"
            echo "  - â˜¸ï¸  EKS Cluster pronto"
            echo "  - ğŸ”— IntegraÃ§Ã£o completa entre componentes"
            echo ""
            echo "ğŸ§ª Testes realizados:"
            echo "  - âœ… AutenticaÃ§Ã£o com CPF vÃ¡lido"
            echo "  - âœ… RejeiÃ§Ã£o de CPF invÃ¡lido"
            echo "  - âœ… GeraÃ§Ã£o de JWT tokens"
            echo ""
            echo "ğŸ”— URLs disponÃ­veis no job test-lambda"
          else
            echo "âŒ FALHA NO DEPLOYMENT"
          fi