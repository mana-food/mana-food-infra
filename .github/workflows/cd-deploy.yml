name: Deploy Mana Food - Simples com Rollback

on:
  workflow_dispatch:
    inputs:
      deploy_mode:
        description: "Modo de deploy"
        type: choice
        options:
          - "full-deploy"
          - "infra-only"
          - "lambda-only"
        default: "full-deploy"
  push:
    branches:
      - main

permissions:
  contents: read
  packages: write
  id-token: write

jobs:
  build-lambda:
    name: 'Build Lambda'
    runs-on: ubuntu-latest
    outputs:
      lambda-success: ${{ steps.build.outcome }}

    steps:
      - name: Checkout Lambda repo
        uses: actions/checkout@v4
        with:
          repository: mana-food/mana-food-lambda
          token: ${{ secrets.PERSONAL_ACCESS_TOKEN_MANA_FOOD_APP }}
          path: lambda-repo

      - name: Setup .NET 9
        uses: actions/setup-dotnet@v3
        with:
          dotnet-version: '9.0.x'

      - name: Build Lambda
        id: build
        run: |
          cd lambda-repo
          SLN_FILE=$(find . -name "*.sln" | head -1)
          
          if [ -n "$SLN_FILE" ]; then
            dotnet restore "$SLN_FILE"
            dotnet build --configuration Release "$SLN_FILE"
            
            LAMBDA_PROJ=$(find . -name "*Lambda*.csproj" -o -name "*Auth*.csproj" | head -1)
            dotnet publish "$LAMBDA_PROJ" --configuration Release --runtime linux-x64 -o publish/
            
            cd publish
            zip -r ../../lambda-deployment.zip .
          else
            echo "Solution n√£o encontrada"
            exit 1
          fi

      - name: Upload Lambda
        uses: actions/upload-artifact@v4
        with:
          name: lambda-deployment-${{ github.run_id }}
          path: lambda-deployment.zip

  build-app:
    name: 'Build App'
    runs-on: ubuntu-latest
    if: github.event.inputs.deploy_mode != 'lambda-only'
    outputs:
      image-tag: ${{ steps.build.outputs.image-tag }}

    steps:
      - name: Checkout App repo
        uses: actions/checkout@v4
        with:
          repository: mana-food/mana-food-clean-architecture
          token: ${{ secrets.PERSONAL_ACCESS_TOKEN_MANA_FOOD_APP }}
          path: app-repo

      - name: Check if real app exists and set image
        id: build
        run: |
          cd app-repo
          
          if [ -f Dockerfile ]; then
            echo "üî® Dockerfile encontrado! Tentando build da aplica√ß√£o real..."
            echo "image-tag=BUILD_REAL_APP" >> $GITHUB_OUTPUT
            echo "Aplica√ß√£o real encontrada, mas pularemos o build por problemas de permiss√£o"
          else
            echo "üì¶ Aplica√ß√£o real n√£o encontrada, usando imagem padr√£o nginx"
            echo "image-tag=nginx:alpine" >> $GITHUB_OUTPUT
          fi

  terraform-deploy:
    name: 'Deploy Infra'
    runs-on: ubuntu-latest
    needs: build-lambda
    defaults:
      run:
        working-directory: infra/terraform/envs/prod
    outputs:
      terraform-success: ${{ steps.apply.outcome }}
      aurora-endpoint: ${{ steps.outputs.outputs.aurora-endpoint }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Configure AWS
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: sa-east-1

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: '1.6.0'
          terraform_wrapper: false

      - name: Download Lambda
        uses: actions/download-artifact@v4
        with:
          name: lambda-deployment-${{ github.run_id }}
          path: infra/terraform/envs/prod

      - name: Fix AWS_REGION in lambda.tf
        run: |
          # Remover AWS_REGION das vari√°veis de ambiente da Lambda
          if grep -q "AWS_REGION" lambda.tf; then
            sed -i '/AWS_REGION.*= var.aws_region/d' lambda.tf
            echo "AWS_REGION removido de lambda.tf"
          fi
          
          # Verificar arquivo
          echo "Conte√∫do do bloco environment:"
          grep -A 10 "environment" lambda.tf || true

      - name: Terraform Init
        run: |
          terraform init \
            -backend-config="bucket=${{ secrets.AWS_TF_STATE_BUCKET }}" \
            -backend-config="key=mana-food-prod.tfstate" \
            -backend-config="region=sa-east-1"

      - name: Terraform Apply
        id: apply
        run: |
          terraform plan -var="bucket_state_name=${{ secrets.AWS_TF_STATE_BUCKET }}" -out=tfplan
          terraform apply -auto-approve tfplan

      - name: Get Outputs
        id: outputs
        if: steps.apply.outcome == 'success'
        run: |
          AURORA_ENDPOINT=$(terraform output -raw aurora_endpoint)
          echo "aurora-endpoint=$AURORA_ENDPOINT" >> $GITHUB_OUTPUT

  setup-database:
    name: 'Setup DB'
    runs-on: ubuntu-latest
    needs: terraform-deploy
    if: needs.terraform-deploy.outputs.terraform-success == 'success'

    steps:
      - name: Configure AWS
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: sa-east-1

      - name: Fix Aurora Security Group for external access
        run: |
          AURORA_ENDPOINT="${{ needs.terraform-deploy.outputs.aurora-endpoint }}"
          echo "Configurando Security Group para Aurora: $AURORA_ENDPOINT"
          
          # Obter Security Groups do Aurora
          AURORA_SG=$(aws rds describe-db-clusters --db-cluster-identifier mana-food-aurora --region sa-east-1 --query 'DBClusters[0].VpcSecurityGroups[0].VpcSecurityGroupId' --output text)
          
          echo "Aurora Security Group: $AURORA_SG"
          
          # Adicionar regra para permitir acesso externo (temporariamente)
          aws ec2 authorize-security-group-ingress \
            --group-id "$AURORA_SG" \
            --protocol tcp \
            --port 3306 \
            --cidr 0.0.0.0/0 \
            --region sa-east-1 || echo "Regra j√° existe"
          
          echo "Regra de acesso 0.0.0.0/0:3306 adicionada"

      - name: Wait for Aurora and configure database
        run: |
          AURORA_ENDPOINT="${{ needs.terraform-deploy.outputs.aurora-endpoint }}"
          DB_PASSWORD="${{ secrets.DB_PASSWORD || 'TempPassword123!' }}"
          
          echo "Aguardando Aurora estar dispon√≠vel..."
          
          # Aguardar status available (j√° est√°, mas para garantir)
          timeout 300 bash -c "
            while true; do
              STATUS=\$(aws rds describe-db-clusters --db-cluster-identifier mana-food-aurora --region sa-east-1 --query 'DBClusters[0].Status' --output text 2>/dev/null || echo 'unknown')
              echo \"Status Aurora: \$STATUS\"
              if [ \"\$STATUS\" = \"available\" ]; then
                echo \"‚úÖ Aurora dispon√≠vel!\"
                break
              fi
              sleep 15
            done
          "
          
          # Aguardar mais um pouco para garantir que est√° pronto
          echo "Aguardando estabiliza√ß√£o..."
          sleep 60

      - name: Setup Database with Docker MySQL client
        run: |
          AURORA_ENDPOINT="${{ needs.terraform-deploy.outputs.aurora-endpoint }}"
          DB_PASSWORD="${{ secrets.DB_PASSWORD || 'TempPassword123!' }}"
          
          echo "Configurando banco de dados..."
          echo "Endpoint: $AURORA_ENDPOINT"
          
          # Configurar database usando Docker MySQL client com rede host
          echo "Tentando conectar ao Aurora..."
          
          timeout 180 docker run --rm --network host mysql:8.0 mysql \
            -h "$AURORA_ENDPOINT" \
            -u admin \
            -p"$DB_PASSWORD" \
            --connect-timeout=30 \
            --wait-timeout=60 \
            -e "
            SET SESSION wait_timeout = 300;
            
            -- Criar database
            CREATE DATABASE IF NOT EXISTS appdb;
            USE appdb;
            
            -- Criar tabela users
            CREATE TABLE IF NOT EXISTS users (
                id CHAR(36) PRIMARY KEY DEFAULT (UUID()),
                cpf VARCHAR(11) NOT NULL UNIQUE,
                name VARCHAR(255),
                email VARCHAR(255),
                user_type INT DEFAULT 1,
                deleted BOOLEAN DEFAULT FALSE,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
                INDEX idx_cpf (cpf),
                INDEX idx_deleted (deleted),
                INDEX idx_user_type (user_type)
            );
            
            -- Inserir dados de teste
            INSERT IGNORE INTO users (id, cpf, name, email, user_type) VALUES 
            (UUID(), '12345678901', 'Cliente Teste Mana Food', 'cliente@test.com', 1),
            (UUID(), '98765432100', 'Admin Sistema Mana Food', 'admin@test.com', 2),
            (UUID(), '11111111111', 'User Padr√£o Mana Food', 'user@manafood.com', 1),
            (UUID(), '22222222222', 'Gerente Mana Food', 'gerente@manafood.com', 3),
            (UUID(), '33333333333', 'Cliente Premium', 'premium@test.com', 1);
            
            -- Verificar dados inseridos
            SELECT 
                COUNT(*) as total_users,
                COUNT(CASE WHEN user_type = 1 THEN 1 END) as clientes,
                COUNT(CASE WHEN user_type = 2 THEN 1 END) as admins,
                COUNT(CASE WHEN user_type = 3 THEN 1 END) as gerentes
            FROM users WHERE deleted = FALSE;
            
            -- Mostrar estrutura da tabela
            DESCRIBE users;
            
            -- Mostrar dados inseridos
            SELECT cpf, name, user_type FROM users ORDER BY user_type, name;
            "
          
          if [ $? -eq 0 ]; then
            echo "‚úÖ Banco de dados configurado com sucesso!"
          else
            echo "‚ùå Falha na configura√ß√£o do banco"
            echo "Tentando diagn√≥stico..."
            
            # Verificar se consegue conectar sem executar SQL
            timeout 30 docker run --rm --network host mysql:8.0 mysql \
              -h "$AURORA_ENDPOINT" \
              -u admin \
              -p"$DB_PASSWORD" \
              --connect-timeout=10 \
              -e "SELECT 1;" && echo "Conex√£o b√°sica OK" || echo "Conex√£o b√°sica falhou"
            
            exit 1
          fi

  configure-lambda:
    name: 'Config Lambda'
    runs-on: ubuntu-latest
    needs: [terraform-deploy, setup-database]

    steps:
      - name: Configure AWS
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: sa-east-1

      - name: Update Lambda
        run: |
          AURORA_ENDPOINT="${{ needs.terraform-deploy.outputs.aurora-endpoint }}"
          CONNECTION_STRING="Server=$AURORA_ENDPOINT;Port=3306;Database=appdb;Uid=admin;Pwd=${{ secrets.DB_PASSWORD || 'TempPassword123!' }};SslMode=Required;"
          
          # Configurar apenas vari√°veis n√£o-reservadas
          aws lambda update-function-configuration \
            --function-name mana-food-api \
            --region sa-east-1 \
            --environment Variables="{
              \"MYSQL_CONNECTION_STRING\":\"$CONNECTION_STRING\",
              \"ASPNETCORE_ENVIRONMENT\":\"Production\",
              \"AURORA_ENDPOINT\":\"$AURORA_ENDPOINT\",
              \"DATABASE_NAME\":\"appdb\"
            }"
          
          # Aguardar atualiza√ß√£o
          aws lambda wait function-updated --function-name mana-food-api --region sa-east-1

  test-lambda:
    name: 'Test Auth'
    runs-on: ubuntu-latest
    needs: configure-lambda

    steps:
      - name: Configure AWS
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: sa-east-1

      - name: Test Lambda
        run: |
          # Teste direto
          echo "Testando Lambda diretamente..."
          aws lambda invoke --function-name mana-food-api --payload '{"cpf":"12345678901"}' response.json
          cat response.json
          
          # Teste API Gateway
          echo "Testando via API Gateway..."
          API_ID=$(aws apigateway get-rest-apis --query 'items[?name==`mana-food-api`].id' --output text)
          if [ "$API_ID" != "None" ] && [ -n "$API_ID" ]; then
            API_URL="https://$API_ID.execute-api.sa-east-1.amazonaws.com/prod"
            echo "API URL: $API_URL"
            
            curl -X POST "$API_URL" -H "Content-Type: application/json" -d '{"cpf":"12345678901"}' || echo "Falha no teste API Gateway"
          else
            echo "API Gateway n√£o encontrado"
          fi

  deploy-app:
    name: 'Deploy App'
    runs-on: ubuntu-latest
    needs: [terraform-deploy, build-app, test-lambda]
    if: github.event.inputs.deploy_mode != 'lambda-only'

    steps:
      - name: Configure AWS
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: sa-east-1

      - name: Setup kubectl
        uses: azure/setup-kubectl@v3

      - name: Deploy to EKS with placeholder app
        run: |
          aws eks update-kubeconfig --region sa-east-1 --name mana-food-eks
          
          # Usar nginx com p√°gina customizada via ConfigMap
          API_ID=$(aws apigateway get-rest-apis --query 'items[?name==`mana-food-api`].id' --output text)
          API_URL="https://$API_ID.execute-api.sa-east-1.amazonaws.com/prod"
          
          echo "üöÄ Deployando app placeholder no EKS..."
          echo "üîó Auth API: $API_URL"
          
          kubectl apply -f - <<EOF
          apiVersion: v1
          kind: ConfigMap
          metadata:
            name: mana-food-html
            namespace: default
          data:
            index.html: |
              <!DOCTYPE html>
              <html lang="pt-BR">
              <head>
                  <meta charset="UTF-8">
                  <meta name="viewport" content="width=device-width, initial-scale=1.0">
                  <title>üçΩÔ∏è Mana Food - Sistema de Autentica√ß√£o</title>
                  <style>
                      body { font-family: Arial, sans-serif; margin: 0; padding: 20px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; }
                      .container { max-width: 800px; margin: 0 auto; text-align: center; }
                      .card { background: rgba(255,255,255,0.1); border-radius: 15px; padding: 30px; margin: 20px 0; backdrop-filter: blur(10px); }
                      .btn { background: #4CAF50; color: white; padding: 10px 20px; border: none; border-radius: 5px; cursor: pointer; margin: 5px; }
                      .result { margin-top: 20px; padding: 15px; border-radius: 10px; background: rgba(255,255,255,0.2); }
                      input { padding: 10px; margin: 5px; border: none; border-radius: 5px; width: 200px; color: black; }
                  </style>
              </head>
              <body>
                  <div class="container">
                      <h1>üçΩÔ∏è Mana Food</h1>
                      <h2>Sistema de Autentica√ß√£o Lambda</h2>
                      
                      <div class="card">
                          <h3>üîê Teste de Autentica√ß√£o</h3>
                          <p>Teste a autentica√ß√£o com CPF usando nossa Lambda Function</p>
                          
                          <div>
                              <input type="text" id="cpf" placeholder="Digite o CPF (apenas n√∫meros)" maxlength="11">
                              <br><br>
                              <button class="btn" onclick="testarAuth()">üöÄ Testar Autentica√ß√£o</button>
                              <button class="btn" onclick="limpar()">üóëÔ∏è Limpar</button>
                          </div>
                          
                          <div id="resultado" class="result" style="display:none;">
                              <h4>Resultado:</h4>
                              <pre id="response"></pre>
                          </div>
                      </div>
                      
                      <div class="card">
                          <h3>üí° CPFs de Teste</h3>
                          <p>Use estes CPFs para testar o sistema:</p>
                          <ul style="text-align: left; display: inline-block;">
                              <li><strong>12345678901</strong> - Cliente Teste</li>
                              <li><strong>98765432100</strong> - Admin Sistema</li>
                              <li><strong>11111111111</strong> - User Padr√£o</li>
                              <li><strong>22222222222</strong> - Gerente</li>
                              <li><strong>33333333333</strong> - Cliente Premium</li>
                          </ul>
                      </div>
                      
                      <div class="card">
                          <h3>üèóÔ∏è Arquitetura do Sistema</h3>
                          <p><strong>üóÑÔ∏è Aurora MySQL:</strong> Banco de dados serverless</p>
                          <p><strong>‚ö° Lambda .NET 9:</strong> API de autentica√ß√£o</p>
                          <p><strong>üåê API Gateway:</strong> $API_URL</p>
                          <p><strong>‚ò∏Ô∏è EKS Cluster:</strong> Kubernetes para aplica√ß√µes</p>
                      </div>
                  </div>
                  
                  <script>
                      const apiUrl = "$API_URL";
                      
                      async function testarAuth() {
                          const cpf = document.getElementById("cpf").value.replace(/\D/g, "");
                          const resultDiv = document.getElementById("resultado");
                          const responseDiv = document.getElementById("response");
                          
                          if (cpf.length !== 11) {
                              alert("‚ùå CPF deve ter 11 d√≠gitos!");
                              return;
                          }
                          
                          resultDiv.style.display = "block";
                          responseDiv.textContent = "üîÑ Testando autentica√ß√£o...";
                          
                          try {
                              const response = await fetch(apiUrl, {
                                  method: "POST",
                                  headers: { "Content-Type": "application/json" },
                                  body: JSON.stringify({ cpf: cpf })
                              });
                              
                              const data = await response.json();
                              responseDiv.textContent = JSON.stringify(data, null, 2);
                              
                              if (response.ok && data.token) {
                                  responseDiv.style.background = "rgba(76, 175, 80, 0.3)";
                              } else {
                                  responseDiv.style.background = "rgba(244, 67, 54, 0.3)";
                              }
                          } catch (error) {
                              responseDiv.textContent = "‚ùå Erro: " + error.message;
                              responseDiv.style.background = "rgba(244, 67, 54, 0.3)";
                          }
                      }
                      
                      function limpar() {
                          document.getElementById("cpf").value = "";
                          document.getElementById("resultado").style.display = "none";
                      }
                      
                      // Auto-formatar CPF
                      document.getElementById("cpf").addEventListener("input", function(e) {
                          e.target.value = e.target.value.replace(/\D/g, "");
                      });
                  </script>
              </body>
              </html>
          ---
          apiVersion: apps/v1
          kind: Deployment
          metadata:
            name: mana-food-app
          spec:
            replicas: 2
            selector:
              matchLabels:
                app: mana-food-app
            template:
              metadata:
                labels:
                  app: mana-food-app
              spec:
                containers:
                - name: app
                  image: nginx:alpine
                  ports:
                  - containerPort: 80
                  volumeMounts:
                  - name: html-content
                    mountPath: /usr/share/nginx/html
                volumes:
                - name: html-content
                  configMap:
                    name: mana-food-html
          ---
          apiVersion: v1
          kind: Service
          metadata:
            name: mana-food-service
          spec:
            selector:
              app: mana-food-app
            ports:
            - port: 80
              targetPort: 80
            type: LoadBalancer
          EOF
          
          kubectl rollout status deployment/mana-food-app --timeout=300s
          kubectl get svc mana-food-service

      - name: Get Load Balancer URL
        run: |
          echo "üåê Obtendo URL do Load Balancer..."
          
          # Aguardar Load Balancer estar pronto
          timeout 300 bash -c '
            while true; do
              LB_HOSTNAME=$(kubectl get svc mana-food-service -o jsonpath="{.status.loadBalancer.ingress[0].hostname}" 2>/dev/null)
              if [ -n "$LB_HOSTNAME" ] && [ "$LB_HOSTNAME" != "null" ]; then
                echo "üîó Aplica√ß√£o Mana Food dispon√≠vel em: http://$LB_HOSTNAME"
                break
              fi
              echo "‚è∞ Aguardando Load Balancer... $(date +%H:%M:%S)"
              sleep 30
            done
          ' || echo "‚ö†Ô∏è Timeout aguardando Load Balancer - verifique manualmente"

  rollback:
    name: 'Rollback'
    runs-on: ubuntu-latest
    needs: [terraform-deploy, setup-database, configure-lambda, test-lambda, deploy-app]
    if: failure() && (needs.terraform-deploy.result == 'success')
    defaults:
      run:
        working-directory: infra/terraform/envs/prod

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Configure AWS
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: sa-east-1

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: '1.6.0'
          terraform_wrapper: false

      - name: Download Lambda (for state)
        uses: actions/download-artifact@v4
        with:
          name: lambda-deployment-${{ github.run_id }}
          path: infra/terraform/envs/prod
        continue-on-error: true

      - name: Terraform Init
        run: |
          terraform init \
            -backend-config="bucket=${{ secrets.AWS_TF_STATE_BUCKET }}" \
            -backend-config="key=mana-food-prod.tfstate" \
            -backend-config="region=sa-east-1"

      - name: Cleanup EKS Apps
        run: |
          aws eks update-kubeconfig --region sa-east-1 --name mana-food-eks || true
          kubectl delete deployment mana-food-app || true
          kubectl delete service mana-food-service || true
          kubectl delete configmap mana-food-html || true
        continue-on-error: true

      - name: Terraform Destroy
        run: |
          echo "üö® Executando rollback - destruindo infraestrutura..."
          terraform destroy -var="bucket_state_name=${{ secrets.AWS_TF_STATE_BUCKET }}" -auto-approve
        continue-on-error: true

      - name: Manual Cleanup
        run: |
          echo "üßπ Limpeza manual de recursos √≥rf√£os..."
          
          # Cleanup Lambda
          aws lambda delete-function --function-name mana-food-api || true
          
          # Cleanup API Gateway
          API_ID=$(aws apigateway get-rest-apis --query 'items[?name==`mana-food-api`].id' --output text)
          if [ "$API_ID" != "None" ]; then
            aws apigateway delete-rest-api --rest-api-id "$API_ID" || true
          fi
          
          # Cleanup Log Groups
          aws logs delete-log-group --log-group-name "/aws/lambda/mana-food-api" || true
          aws logs delete-log-group --log-group-name "/aws/eks/mana-food-eks/cluster" || true
          
          echo "‚úÖ Rollback conclu√≠do"

  status:
    name: 'Status'
    runs-on: ubuntu-latest
    needs: [terraform-deploy, test-lambda, deploy-app, rollback]
    if: always()

    steps:
      - name: Report
        run: |
          echo "üéØ MANA FOOD DEPLOYMENT"
          echo "======================="
          echo "Infraestrutura: ${{ needs.terraform-deploy.result }}"
          echo "Auth Lambda: ${{ needs.test-lambda.result }}"
          echo "App EKS: ${{ needs.deploy-app.result }}"
          echo "Rollback: ${{ needs.rollback.result }}"
          echo ""
          
          if [ "${{ needs.rollback.result }}" = "success" ]; then
            echo "üö® ROLLBACK EXECUTADO - Infraestrutura removida"
          elif [ "${{ needs.terraform-deploy.result }}" = "success" ]; then
            echo "‚úÖ Sistema deployado!"
            echo "üîë CPFs de teste: 12345678901, 98765432100, 11111111111, 22222222222, 33333333333"
            echo "üåê Acesse a aplica√ß√£o via Load Balancer para testar"
          else
            echo "‚ùå Falha no deployment"
          fi