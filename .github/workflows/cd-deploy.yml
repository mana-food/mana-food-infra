name: Deploy Mana Food - Aurora RDS + Secrets Manager

on:
  workflow_dispatch:
    inputs:
      deploy_mode:
        description: "Modo de deploy"
        type: choice
        options:
          - "full-deploy"
          - "infra-only"
          - "lambda-only"
        default: "full-deploy"
  push:
    branches:
      - main

permissions:
  contents: read
  packages: write
  id-token: write

env:
  ECR_REPOSITORY_GATEWAY: mana-food-gateway
  ECR_REPOSITORY_API: mana-food-api
  AWS_REGION: us-east-1

jobs:
  # ===================================================================
  # FASE 1: BUILD PARALELO (N√£o dependem de infra)
  # ===================================================================
  build-lambda:
    name: 'Build Lambda .NET 9'
    runs-on: ubuntu-latest
    outputs:
      lambda-success: ${{ steps.build.outcome }}

    steps:
      - name: Checkout Lambda repo
        uses: actions/checkout@v4
        with:
          repository: mana-food/mana-food-lambda
          token: ${{ secrets.PERSONAL_ACCESS_TOKEN_MANA_FOOD_APP }}
          path: lambda-repo

      - name: Setup .NET 9
        uses: actions/setup-dotnet@v3
        with:
          dotnet-version: '9.0.x'

      - name: Build Lambda .NET 9
        id: build
        run: |
          cd lambda-repo
          SLN_FILE=$(find . -name "*.sln" | head -1)
          
          if [ -n "$SLN_FILE" ]; then
            dotnet restore "$SLN_FILE"
            dotnet build --configuration Release "$SLN_FILE"
            
            LAMBDA_PROJ=$(find . -name "*Lambda*.csproj" -o -name "*Auth*.csproj" | head -1)
            dotnet publish "$LAMBDA_PROJ" --configuration Release --runtime linux-x64 -o publish/
            
            cd publish
            zip -r ../../lambda-deployment.zip .
          else
            echo "Solution n√£o encontrada"
            exit 1
          fi

      - name: Upload Lambda
        uses: actions/upload-artifact@v4
        with:
          name: lambda-deployment-${{ github.run_id }}
          path: lambda-deployment.zip

  build-apps:
    name: 'Build Gateway & API .NET 9'
    runs-on: ubuntu-latest
    if: github.event.inputs.deploy_mode != 'lambda-only'
    outputs:
      gateway-image: ${{ steps.build-gateway.outputs.image-uri }}
      api-image: ${{ steps.build-api.outputs.image-uri }}
      build-success: ${{ steps.check.outputs.success }}

    steps:
      - name: Checkout App repo
        uses: actions/checkout@v4
        with:
          repository: mana-food/mana-food-clean-architecture
          token: ${{ secrets.PERSONAL_ACCESS_TOKEN_MANA_FOOD_APP }}
          path: app-repo

      - name: Configure AWS
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Create ECR repositories
        run: |
          aws ecr describe-repositories --repository-names $ECR_REPOSITORY_GATEWAY --region ${{ env.AWS_REGION }} || \
          aws ecr create-repository --repository-name $ECR_REPOSITORY_GATEWAY --region ${{ env.AWS_REGION }}
          
          aws ecr describe-repositories --repository-names $ECR_REPOSITORY_API --region ${{ env.AWS_REGION }} || \
          aws ecr create-repository --repository-name $ECR_REPOSITORY_API --region ${{ env.AWS_REGION }}

      - name: Build Gateway .NET 9
        id: build-gateway
        run: |
          cd app-repo
          
          ECR_REGISTRY=${{ steps.login-ecr.outputs.registry }}
          IMAGE_TAG=${{ github.sha }}
          GATEWAY_IMAGE_URI=$ECR_REGISTRY/$ECR_REPOSITORY_GATEWAY:$IMAGE_TAG
          
          # Criar Dockerfile para Gateway
          cat > Gateway/Dockerfile << 'EOF'
          FROM mcr.microsoft.com/dotnet/aspnet:9.0 AS base
          WORKDIR /app
          EXPOSE 8080
          ENV ASPNETCORE_URLS=http://+:8080
          
          FROM mcr.microsoft.com/dotnet/sdk:9.0 AS build
          WORKDIR /src
          COPY . .
          WORKDIR /src/Gateway
          RUN dotnet restore
          RUN dotnet publish -c Release -o /app/publish
          
          FROM base AS final
          WORKDIR /app
          COPY --from=build /app/publish .
          ENTRYPOINT ["dotnet", "Gateway.dll"]
          EOF
          
          # Build Gateway
          docker build -f Gateway/Dockerfile -t $GATEWAY_IMAGE_URI .
          docker push $GATEWAY_IMAGE_URI
          
          echo "image-uri=$GATEWAY_IMAGE_URI" >> $GITHUB_OUTPUT
          echo "‚úÖ Gateway .NET 9: $GATEWAY_IMAGE_URI"

      - name: Build API .NET 9
        id: build-api
        run: |
          cd app-repo
          
          ECR_REGISTRY=${{ steps.login-ecr.outputs.registry }}
          IMAGE_TAG=${{ github.sha }}
          API_IMAGE_URI=$ECR_REGISTRY/$ECR_REPOSITORY_API:$IMAGE_TAG
          
          # Build API .NET 9 com migrations
          docker build -f Presentation/ManaFood.WebAPI/Dockerfile -t $API_IMAGE_URI .
          docker push $API_IMAGE_URI
          
          echo "image-uri=$API_IMAGE_URI" >> $GITHUB_OUTPUT
          echo "‚úÖ API .NET 9: $API_IMAGE_URI"

      - name: Check builds
        id: check
        run: |
          echo "success=true" >> $GITHUB_OUTPUT

  # ===================================================================
  # FASE 2: INFRAESTRUTURA CR√çTICA (VPC + Aurora - 15-20 min)
  # ===================================================================
  terraform-foundation:
    name: 'Deploy VPC + Aurora (Wave 1) - 15-20 min'
    runs-on: ubuntu-latest
    needs: build-lambda
    defaults:
      run:
        working-directory: infra/terraform/envs/prod
    outputs:
      terraform-success: ${{ steps.apply.outcome }}
      aurora-endpoint: ${{ steps.outputs.outputs.aurora-endpoint }}
      aurora-secret-arn: ${{ steps.outputs.outputs.aurora-secret-arn }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Configure AWS
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: '1.6.0'
          terraform_wrapper: false

      - name: Download Lambda
        uses: actions/download-artifact@v4
        with:
          name: lambda-deployment-${{ github.run_id }}
          path: infra/terraform/envs/prod

      - name: Terraform Init
        run: |
          terraform init \
            -backend-config="bucket=${{ secrets.AWS_TF_STATE_BUCKET }}" \
            -backend-config="key=mana-food-prod.tfstate" \
            -backend-config="region=${{ env.AWS_REGION }}"

      - name: Terraform Apply - Foundation
        id: apply
        run: |
          echo "üöÄ Criando infraestrutura base: VPC + Aurora MySQL (15-20 min)..."
          terraform plan -var="bucket_state_name=${{ secrets.AWS_TF_STATE_BUCKET }}" -out=tfplan
          terraform apply -auto-approve tfplan

      - name: Get Foundation Outputs
        id: outputs
        if: steps.apply.outcome == 'success'
        run: |
          AURORA_ENDPOINT=$(terraform output -raw aurora_endpoint)
          AURORA_SECRET_ARN=$(terraform output -raw aurora_secret_arn)
          
          echo "aurora-endpoint=$AURORA_ENDPOINT" >> $GITHUB_OUTPUT
          echo "aurora-secret-arn=$AURORA_SECRET_ARN" >> $GITHUB_OUTPUT
          
          echo "‚úÖ Aurora Endpoint: $AURORA_ENDPOINT"
          echo "üîê Aurora Secret ARN: $AURORA_SECRET_ARN"

  # ===================================================================
  # FASE 3: AGUARDAR AURORA (Cr√≠tico - 15-20 min)
  # ===================================================================
  wait-aurora:
    name: 'Aguardar Aurora Dispon√≠vel (15-20 min)'
    runs-on: ubuntu-latest
    needs: terraform-foundation
    if: needs.terraform-foundation.outputs.terraform-success == 'success'

    steps:
      - name: Configure AWS
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Wait for Aurora availability
        run: |
          echo "‚è≥ Aguardando Aurora estar dispon√≠vel (pode demorar 15-20 min)..."
          
          # Timeout aumentado para 1200s (20 min) - Aurora Serverless v2 pode demorar
          timeout 1200 bash -c "
            ATTEMPT=0
            while true; do
              ATTEMPT=\$((ATTEMPT+1))
              STATUS=\$(aws rds describe-db-clusters --db-cluster-identifier mana-food-aurora --region ${{ env.AWS_REGION }} --query 'DBClusters[0].Status' --output text 2>/dev/null || echo 'unknown')
              
              echo \"Tentativa \$ATTEMPT - Status atual: \$STATUS\"
              
              if [ \"\$STATUS\" = \"available\" ]; then
                echo \"‚úÖ Aurora dispon√≠vel!\"
                exit 0
              fi
              
              if [ \"\$STATUS\" = \"failed\" ] || [ \"\$STATUS\" = \"deleting\" ]; then
                echo \"‚ùå Aurora em estado cr√≠tico: \$STATUS\"
                exit 1
              fi
              
              if [ \"\$STATUS\" = \"unknown\" ]; then
                # Debug extra a cada 4 tentativas quando ainda unknown
                if [ \$((ATTEMPT % 4)) -eq 0 ]; then
                  echo \"üîé Debug: listando clusters vis√≠veis...\"
                  aws rds describe-db-clusters --region ${{ env.AWS_REGION }} --query 'DBClusters[].{Id:DBClusterIdentifier,Status:Status}' || true
                fi
              fi
              
              sleep 30
            done
          "

      - name: Verify Secrets Manager
        run: |
          SECRET_ARN="${{ needs.terraform-foundation.outputs.aurora-secret-arn }}"
          echo "üîê Verificando AWS Secrets Manager..."
          echo "Secret ARN: $SECRET_ARN"
          
          # Testar acesso ao secret
          aws secretsmanager describe-secret --secret-id "$SECRET_ARN" --region ${{ env.AWS_REGION }}
          echo "‚úÖ AWS Secrets Manager configurado corretamente"

  # ===================================================================
  # FASE 4: INFRAESTRUTURA COMPUTE (EKS + Lambda - 8-12 min)
  # ===================================================================
  terraform-compute:
    name: 'Deploy EKS + Lambda (Wave 2) - 8-12 min'
    runs-on: ubuntu-latest
    needs: [terraform-foundation, wait-aurora]
    defaults:
      run:
        working-directory: infra/terraform/envs/prod
    outputs:
      lambda-function-name: ${{ steps.outputs.outputs.lambda-function-name }}
      lambda-api-url: ${{ steps.outputs.outputs.lambda-api-url }}
      eks-ready: ${{ steps.verify-eks.outcome }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Configure AWS
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: '1.6.0'
          terraform_wrapper: false

      - name: Download Lambda
        uses: actions/download-artifact@v4
        with:
          name: lambda-deployment-${{ github.run_id }}
          path: infra/terraform/envs/prod

      - name: Terraform Init
        run: |
          terraform init \
            -backend-config="bucket=${{ secrets.AWS_TF_STATE_BUCKET }}" \
            -backend-config="key=mana-food-prod.tfstate" \
            -backend-config="region=${{ env.AWS_REGION }}"

      - name: Get Compute Outputs
        id: outputs
        run: |
          # Aurora j√° existe, pegar outros outputs
          LAMBDA_FUNCTION_NAME=$(terraform output -raw lambda_function_name)
          LAMBDA_API_URL=$(terraform output -raw lambda_api_url)
          
          echo "lambda-function-name=$LAMBDA_FUNCTION_NAME" >> $GITHUB_OUTPUT
          echo "lambda-api-url=$LAMBDA_API_URL" >> $GITHUB_OUTPUT
          
          echo "‚ö° Lambda Function: $LAMBDA_FUNCTION_NAME"
          echo "üåê Lambda API URL: $LAMBDA_API_URL"

      - name: Verify EKS Ready
        id: verify-eks
        run: |
          echo "üîç Verificando se EKS est√° pronto..."
          
          # Aguardar EKS cluster estar ativo
          aws eks wait cluster-active --name mana-food-eks --region ${{ env.AWS_REGION }}
          
          # Configurar kubectl
          aws eks update-kubeconfig --region ${{ env.AWS_REGION }} --name mana-food-eks
          
          # Verificar nodes prontos
          timeout 300 bash -c "
            while true; do
              READY_NODES=\$(kubectl get nodes --no-headers | grep Ready | wc -l)
              if [ \"\$READY_NODES\" -ge 2 ]; then
                echo \"‚úÖ EKS cluster pronto com \$READY_NODES nodes\"
                break
              fi
              echo \"‚è≥ Aguardando nodes EKS (\$READY_NODES/2 prontos)...\"
              sleep 30
            done
          "
          
          echo "‚úÖ EKS cluster completamente operacional"

  # ===================================================================
  # FASE 5: CONFIGURA√á√ÉO E DEPLOY (2-5 min)
  # ===================================================================
  configure-lambda:
    name: 'Config Lambda .NET 9 - Secrets Manager'
    runs-on: ubuntu-latest
    needs: [terraform-foundation, wait-aurora, terraform-compute]

    steps:
      - name: Configure AWS
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Wait for Lambda and IAM propagation
        run: |
          echo "‚è≥ Aguardando Lambda function e propaga√ß√£o IAM..."
          sleep 30
          
          LAMBDA_FUNCTION_NAME="${{ needs.terraform-compute.outputs.lambda-function-name }}"
          aws lambda wait function-active --function-name "$LAMBDA_FUNCTION_NAME" --region ${{ env.AWS_REGION }}
          echo "‚úÖ Lambda function ativa"

      - name: Configure Lambda with Secrets Manager
        shell: bash
        run: |
          set -euo pipefail
          # Desabilita history expansion para n√£o interferir com '!' do ARN
          set +H

          AURORA_SECRET_ARN="${{ needs.terraform-foundation.outputs.aurora-secret-arn }}"
          LAMBDA_FUNCTION_NAME="${{ needs.terraform-compute.outputs.lambda-function-name }}"

          echo "üîß Configurando Lambda .NET 9 com AWS Secrets Manager..."
          echo "üîê Secret ARN: $AURORA_SECRET_ARN"
          echo "‚ö° Fun√ß√£o: $LAMBDA_FUNCTION_NAME"

          # Formato exigido: Variables={K=V,K=V,...} (N√ÉO usar JSON)
          ENV_VARS="AURORA_SECRET_ARN=$AURORA_SECRET_ARN,ASPNETCORE_ENVIRONMENT=Production"
          aws lambda update-function-configuration \
            --function-name "$LAMBDA_FUNCTION_NAME" \
            --region ${{ env.AWS_REGION }} \
            --environment "Variables={$ENV_VARS}"

          echo "‚è≥ Aguardando atualiza√ß√£o..."
          aws lambda wait function-updated --function-name "$LAMBDA_FUNCTION_NAME" --region ${{ env.AWS_REGION }}

          echo "‚úÖ Lambda atualizada. Vari√°veis aplicadas:"
          aws lambda get-function-configuration \
            --function-name "$LAMBDA_FUNCTION_NAME" \
            --query 'Environment.Variables' \
            --region ${{ env.AWS_REGION }}

  deploy-apps:
    name: 'Deploy Gateway & API .NET 9 no EKS'
    runs-on: ubuntu-latest
    needs: [terraform-foundation, build-apps, terraform-compute, configure-lambda]
    if: needs.build-apps.outputs.build-success == 'true' && needs.terraform-compute.outputs.eks-ready == 'success'

    steps:
      - name: Configure AWS
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup kubectl
        uses: azure/setup-kubectl@v3

      - name: Configure kubectl and verify IAM
        run: |
          aws eks update-kubeconfig --region ${{ env.AWS_REGION }} --name mana-food-eks
          
          echo "üîç Verificando se EKS nodes podem acessar Secrets Manager..."
          SECRET_ARN="${{ needs.terraform-foundation.outputs.aurora-secret-arn }}"
          
          # Teste b√°sico de conectividade
          aws secretsmanager describe-secret --secret-id "$SECRET_ARN" --region ${{ env.AWS_REGION }}
          echo "‚úÖ Secret est√° acess√≠vel"

      - name: Deploy aplica√ß√µes .NET 9 no EKS
        run: |
          # Configura√ß√µes
          GATEWAY_IMAGE="${{ needs.build-apps.outputs.gateway-image }}"
          API_IMAGE="${{ needs.build-apps.outputs.api-image }}"
          AURORA_ENDPOINT="${{ needs.terraform-foundation.outputs.aurora-endpoint }}"
          AURORA_SECRET_ARN="${{ needs.terraform-foundation.outputs.aurora-secret-arn }}"
          LAMBDA_API_URL="${{ needs.terraform-compute.outputs.lambda-api-url }}"
          
          # Obter URL da Lambda de autentica√ß√£o (fallback se needed)
          API_ID=$(aws apigateway get-rest-apis --query 'items[?name==`mana-food-api`].id' --output text)
          LAMBDA_AUTH_URL="https://$API_ID.execute-api.${{ env.AWS_REGION }}.amazonaws.com/prod"
          
          echo "üöÄ Deployando ManaFood .NET 9 no EKS com AWS Secrets Manager..."
          echo "üåê Gateway .NET 9: $GATEWAY_IMAGE"
          echo "üì± API .NET 9: $API_IMAGE"
          echo "‚ö° Lambda .NET 9: $LAMBDA_AUTH_URL"
          echo "üóÑÔ∏è Aurora RDS: $AURORA_ENDPOINT"
          echo "üîê Aurora Secret: $AURORA_SECRET_ARN"
          echo "üìã API .NET 9 aplicar√° migrations automaticamente"
          
          # Deploy seguindo arquitetura obrigat√≥ria com Secrets Manager
          kubectl apply -f - <<EOF
          # Secrets com Aurora Secret ARN
          apiVersion: v1
          kind: Secret
          metadata:
            name: mana-food-secrets
            namespace: default
          type: Opaque
          stringData:
            aurora-secret-arn: "$AURORA_SECRET_ARN"
            lambda-auth-url: "$LAMBDA_AUTH_URL"
          ---
          # ConfigMap
          apiVersion: v1
          kind: ConfigMap
          metadata:
            name: mana-food-config
            namespace: default
          data:
            ASPNETCORE_ENVIRONMENT: "Production"
            ASPNETCORE_URLS: "http://+:8080"
            DATABASE_HOST: "$AURORA_ENDPOINT"
            API_BASE_URL: "http://mana-food-api-service:8080"
            LAMBDA_URL: "$LAMBDA_API_URL"
          ---
          # API .NET 9 Deployment (aplica migrations automaticamente)
          apiVersion: apps/v1
          kind: Deployment
          metadata:
            name: mana-food-api
            namespace: default
          spec:
            replicas: 2
            selector:
              matchLabels:
                app: mana-food-api
            template:
              metadata:
                labels:
                  app: mana-food-api
              spec:
                containers:
                - name: api
                  image: $API_IMAGE
                  ports:
                  - containerPort: 8080
                  env:
                  # ‚úÖ NOVA CONFIGURA√á√ÉO: Usar Secret ARN
                  - name: AURORA_SECRET_ARN
                    valueFrom:
                      secretKeyRef:
                        name: mana-food-secrets
                        key: aurora-secret-arn
                  envFrom:
                  - configMapRef:
                      name: mana-food-config
                  resources:
                    requests:
                      memory: "256Mi"
                      cpu: "250m"
                    limits:
                      memory: "512Mi"
                      cpu: "500m"
                  startupProbe:
                    httpGet:
                      path: /healthz
                      port: 8080
                    initialDelaySeconds: 10
                    periodSeconds: 5
                    timeoutSeconds: 3
                    failureThreshold: 12
                  readinessProbe:
                    httpGet:
                      path: /healthz
                      port: 8080
                    initialDelaySeconds: 30
                    periodSeconds: 5
                    timeoutSeconds: 3
                    failureThreshold: 2
                  livenessProbe:
                    httpGet:
                      path: /healthz
                      port: 8080
                    initialDelaySeconds: 60
                    periodSeconds: 10
                    timeoutSeconds: 5
                    failureThreshold: 3
          ---
          # Gateway .NET 9 Deployment
          apiVersion: apps/v1
          kind: Deployment
          metadata:
            name: mana-food-gateway
            namespace: default
          spec:
            replicas: 2
            selector:
              matchLabels:
                app: mana-food-gateway
            template:
              metadata:
                labels:
                  app: mana-food-gateway
              spec:
                containers:
                - name: gateway
                  image: $GATEWAY_IMAGE
                  ports:
                  - containerPort: 8080
                  env: []
                  envFrom:
                  - configMapRef:
                      name: mana-food-config
                  resources:
                    requests:
                      memory: "128Mi"
                      cpu: "100m"
                    limits:
                      memory: "256Mi"
                      cpu: "250m"
                  startupProbe:
                    httpGet:
                      path: /healthz
                      port: 8080
                    initialDelaySeconds: 5
                    periodSeconds: 3
                    timeoutSeconds: 3
                    failureThreshold: 10
                  readinessProbe:
                    httpGet:
                      path: /healthz
                      port: 8080
                    initialDelaySeconds: 15
                    periodSeconds: 5
                    timeoutSeconds: 3
                    failureThreshold: 2
                  livenessProbe:
                    httpGet:
                      path: /healthz
                      port: 8080
                    initialDelaySeconds: 30
                    periodSeconds: 10
                    timeoutSeconds: 3
                    failureThreshold: 3
          ---
          # API Service (interno)
          apiVersion: v1
          kind: Service
          metadata:
            name: mana-food-api-service
            namespace: default
          spec:
            selector:
              app: mana-food-api
            ports:
            - port: 8080
              targetPort: 8080
            type: ClusterIP
          ---
          # Gateway Service (p√∫blico)
          apiVersion: v1
          kind: Service
          metadata:
            name: mana-food-gateway-service
            namespace: default
          spec:
            selector:
              app: mana-food-gateway
            ports:
            - port: 80
              targetPort: 8080
            type: LoadBalancer
          EOF

      - name: Monitor deployment progress
        run: |
          echo "üîç Verificando status dos pods..."
          kubectl get pods -l app=mana-food-api -o wide
          kubectl get pods -l app=mana-food-gateway -o wide
          
          echo "‚è≥ Aguardando API aplicar migrations com credenciais do Secrets Manager..."
          kubectl rollout status deployment/mana-food-api --timeout=300s
          
          echo "‚è≥ Aguardando Gateway..."
          kubectl rollout status deployment/mana-food-gateway --timeout=120s
          
          echo "üìä Status final dos pods:"
          kubectl get pods -o wide
          kubectl get svc -o wide

      - name: Verificar arquitetura deployada
        run: |
          echo "üîç Logs da API (migrations com Secrets Manager):"
          kubectl logs deployment/mana-food-api --tail=30 || echo "Logs ainda n√£o dispon√≠veis"
          
          echo ""
          echo "üåê Aguardando Load Balancer do Gateway..."
          
          timeout 300 bash -c '
            while true; do
              LB_HOSTNAME=$(kubectl get svc mana-food-gateway-service -o jsonpath="{.status.loadBalancer.ingress[0].hostname}" 2>/dev/null)
              if [ -n "$LB_HOSTNAME" ] && [ "$LB_HOSTNAME" != "null" ]; then
                echo "üîó ManaFood Gateway: http://$LB_HOSTNAME"
                echo ""
                echo "‚úÖ ARQUITETURA MANA FOOD DEPLOYADA COM AWS SECRETS MANAGER!"
                echo "üèóÔ∏è Fluxo: Internet ‚Üí Gateway .NET 9 ‚Üí {Lambda .NET 9 (auth) + API .NET 9 (business)} ‚Üí Aurora RDS"
                echo "üîê Lambda .NET 9 e API .NET 9 obt√™m credenciais via AWS Secrets Manager"
                echo "üìã Aplica√ß√£o .NET 9 aplicou migrations automaticamente"
                echo "‚ö° Lambda .NET 9 e API .NET 9 conectadas ao mesmo Aurora RDS"
                break
              fi
              echo "‚è∞ Aguardando Load Balancer..."
              sleep 30
            done
          ' || echo "‚ö†Ô∏è Timeout aguardando Load Balancer"

  # ===================================================================
  # ROLLBACK E STATUS
  # ===================================================================
  rollback:
    name: 'Rollback'
    runs-on: ubuntu-latest
    needs: [terraform-foundation, terraform-compute, configure-lambda, deploy-apps]
    if: failure() && (needs.terraform-foundation.result == 'success')
    defaults:
      run:
        working-directory: infra/terraform/envs/prod

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Configure AWS
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: '1.6.0'
          terraform_wrapper: false

      - name: Terraform Init
        run: |
          terraform init \
            -backend-config="bucket=${{ secrets.AWS_TF_STATE_BUCKET }}" \
            -backend-config="key=mana-food-prod.tfstate" \
            -backend-config="region=${{ env.AWS_REGION }}"

      - name: Cleanup EKS Apps
        run: |
          echo "üßπ Limpando aplica√ß√µes do EKS..."
          aws eks update-kubeconfig --region ${{ env.AWS_REGION }} --name mana-food-eks || true
          kubectl delete deployment mana-food-api mana-food-gateway || true
          kubectl delete service mana-food-api-service mana-food-gateway-service || true
          kubectl delete configmap mana-food-config || true
          kubectl delete secret mana-food-secrets || true
        continue-on-error: true

      - name: Terraform Destroy
        run: |
          echo "üö® Executando rollback da infraestrutura..."
          terraform destroy -var="bucket_state_name=${{ secrets.AWS_TF_STATE_BUCKET }}" -auto-approve
        continue-on-error: true

      - name: Cleanup ECR Images
        run: |
          echo "üóëÔ∏è Limpando imagens ECR..."
          aws ecr delete-repository --repository-name mana-food-gateway --force --region ${{ env.AWS_REGION }} || true
          aws ecr delete-repository --repository-name mana-food-api --force --region ${{ env.AWS_REGION }} || true
        continue-on-error: true

  status:
    name: 'Status Final'
    runs-on: ubuntu-latest
    needs: [terraform-foundation, build-apps, wait-aurora, terraform-compute, configure-lambda, deploy-apps, rollback]
    if: always()

    steps:
      - name: Generate report
        run: |
          echo "üéØ MANA FOOD - ARQUITETURA OBRIGAT√ìRIA COM AWS SECRETS MANAGER"
          echo "=============================================================="
          echo "Foundation (VPC+Aurora): ${{ needs.terraform-foundation.result }}"
          echo "Build Apps: ${{ needs.build-apps.result }}"
          echo "Aurora Wait: ${{ needs.wait-aurora.result }}"
          echo "Compute (EKS+Lambda): ${{ needs.terraform-compute.result }}"
          echo "Lambda Config: ${{ needs.configure-lambda.result }}"
          echo "Apps Deploy: ${{ needs.deploy-apps.result }}"
          echo "Rollback: ${{ needs.rollback.result }}"
          echo ""
          
          if [ "${{ needs.rollback.result }}" = "success" ]; then
            echo "üö® ROLLBACK EXECUTADO COM SUCESSO"
            echo "  ‚Ä¢ Aplica√ß√µes EKS removidas"
            echo "  ‚Ä¢ Infraestrutura AWS destru√≠da"
            echo "  ‚Ä¢ Imagens ECR limpas"
          elif [ "${{ needs.deploy-apps.result }}" = "success" ]; then
            echo "‚úÖ MANA FOOD DEPLOYADO SEGUINDO REGRAS OBRIGAT√ìRIAS!"
            echo ""
            echo "üèóÔ∏è ARQUITETURA IMPLEMENTADA:"
            echo "  üóÑÔ∏è Aurora MySQL RDS - Banco central √∫nico"
            echo "  ‚ö° Lambda .NET 9 - Autentica√ß√£o (serverless AWS)"
            echo "  üåê Gateway .NET 9 - Proxy (EKS)"
            echo "  üì± API .NET 9 - Business + Migrations autom√°ticas (EKS)"
            echo "  üîê AWS Secrets Manager - Credenciais seguras"
            echo ""
            echo "üîÑ FLUXO CORRETO:"
            echo "  Cliente ‚Üí Gateway .NET 9 ‚Üí {Lambda .NET 9 (auth) + API .NET 9 (business)} ‚Üí Aurora RDS"
            echo ""
            echo "‚úÖ REGRAS SEGUIDAS:"
            echo "  ‚Ä¢ Aurora RDS como fonte √∫nica"
            echo "  ‚Ä¢ AWS Secrets Manager para credenciais"
            echo "  ‚Ä¢ Aplica√ß√£o aplica migrations na inicializa√ß√£o"
            echo "  ‚Ä¢ Lambda serverless AWS + Gateway/App no EKS"
            echo "  ‚Ä¢ Todos conectam ao mesmo Aurora MySQL"
            echo "  ‚Ä¢ APENAS .NET 9 (sem Lambda Python)"
            echo "  ‚Ä¢ N√ÉO usou connection strings hardcoded"
            echo "  ‚Ä¢ N√ÉO usou setup via Docker externo"
            echo ""
            echo "‚è±Ô∏è TIMELINE OTIMIZADA:"
            echo "  Phase 1: Build Apps (3-5 min) | Foundation Deploy (parallel)"
            echo "  Phase 2: Aurora Wait (15-20 min)"
            echo "  Phase 3: EKS+Lambda Deploy (8-12 min)"
            echo "  Phase 4: App Deploy (2-3 min)"
            echo "  üéØ Total: ~25-30 min (vs 35-45 min anterior)"
          else
            echo "‚ùå Falha no deployment"
          fi