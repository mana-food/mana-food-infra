name: Deploy Mana Food - RDS Centralizado

on:
  workflow_dispatch:
    inputs:
      deploy_mode:
        description: "Modo de deploy"
        type: choice
        options:
          - "full-deploy"
          - "infra-only"
          - "lambda-only"
        default: "full-deploy"
  push:
    branches:
      - main

permissions:
  contents: read
  packages: write
  id-token: write

env:
  ECR_REPOSITORY_GATEWAY: mana-food-gateway
  ECR_REPOSITORY_API: mana-food-api

jobs:
  build-lambda:
    name: 'Build Lambda .NET 9'
    runs-on: ubuntu-latest
    outputs:
      lambda-success: ${{ steps.build.outcome }}

    steps:
      - name: Checkout Lambda repo
        uses: actions/checkout@v4
        with:
          repository: mana-food/mana-food-lambda
          token: ${{ secrets.PERSONAL_ACCESS_TOKEN_MANA_FOOD_APP }}
          path: lambda-repo

      - name: Setup .NET 9
        uses: actions/setup-dotnet@v3
        with:
          dotnet-version: '9.0.x'

      - name: Build Lambda .NET 9
        id: build
        run: |
          cd lambda-repo
          SLN_FILE=$(find . -name "*.sln" | head -1)
          
          if [ -n "$SLN_FILE" ]; then
            dotnet restore "$SLN_FILE"
            dotnet build --configuration Release "$SLN_FILE"
            
            LAMBDA_PROJ=$(find . -name "*Lambda*.csproj" -o -name "*Auth*.csproj" | head -1)
            dotnet publish "$LAMBDA_PROJ" --configuration Release --runtime linux-x64 -o publish/
            
            cd publish
            zip -r ../../lambda-deployment.zip .
          else
            echo "Solution não encontrada"
            exit 1
          fi

      - name: Upload Lambda
        uses: actions/upload-artifact@v4
        with:
          name: lambda-deployment-${{ github.run_id }}
          path: lambda-deployment.zip

  build-apps:
    name: 'Build Gateway & API .NET 9'
    runs-on: ubuntu-latest
    if: github.event.inputs.deploy_mode != 'lambda-only'
    outputs:
      gateway-image: ${{ steps.build-gateway.outputs.image-uri }}
      api-image: ${{ steps.build-api.outputs.image-uri }}
      build-success: ${{ steps.check.outputs.success }}

    steps:
      - name: Checkout App repo
        uses: actions/checkout@v4
        with:
          repository: mana-food/mana-food-clean-architecture
          token: ${{ secrets.PERSONAL_ACCESS_TOKEN_MANA_FOOD_APP }}
          path: app-repo

      - name: Configure AWS
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: sa-east-1

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Create ECR repositories
        run: |
          aws ecr describe-repositories --repository-names $ECR_REPOSITORY_GATEWAY --region sa-east-1 || \
          aws ecr create-repository --repository-name $ECR_REPOSITORY_GATEWAY --region sa-east-1
          
          aws ecr describe-repositories --repository-names $ECR_REPOSITORY_API --region sa-east-1 || \
          aws ecr create-repository --repository-name $ECR_REPOSITORY_API --region sa-east-1

      - name: Build Gateway .NET 9
        id: build-gateway
        run: |
          cd app-repo
          
          ECR_REGISTRY=${{ steps.login-ecr.outputs.registry }}
          IMAGE_TAG=${{ github.sha }}
          GATEWAY_IMAGE_URI=$ECR_REGISTRY/$ECR_REPOSITORY_GATEWAY:$IMAGE_TAG
          
          # Criar Dockerfile para Gateway
          cat > Gateway/Dockerfile << 'EOF'
          FROM mcr.microsoft.com/dotnet/aspnet:9.0 AS base
          WORKDIR /app
          EXPOSE 8080
          ENV ASPNETCORE_URLS=http://+:8080
          
          FROM mcr.microsoft.com/dotnet/sdk:9.0 AS build
          WORKDIR /src
          COPY . .
          WORKDIR /src/Gateway
          RUN dotnet restore
          RUN dotnet publish -c Release -o /app/publish
          
          FROM base AS final
          WORKDIR /app
          COPY --from=build /app/publish .
          ENTRYPOINT ["dotnet", "Gateway.dll"]
          EOF
          
          # Build Gateway
          docker build -f Gateway/Dockerfile -t $GATEWAY_IMAGE_URI .
          docker push $GATEWAY_IMAGE_URI
          
          echo "image-uri=$GATEWAY_IMAGE_URI" >> $GITHUB_OUTPUT
          echo "✅ Gateway .NET 9: $GATEWAY_IMAGE_URI"

      - name: Build API .NET 9
        id: build-api
        run: |
          cd app-repo
          
          ECR_REGISTRY=${{ steps.login-ecr.outputs.registry }}
          IMAGE_TAG=${{ github.sha }}
          API_IMAGE_URI=$ECR_REGISTRY/$ECR_REPOSITORY_API:$IMAGE_TAG
          
          # Build API .NET 9 com migrations
          docker build -f Presentation/ManaFood.WebAPI/Dockerfile -t $API_IMAGE_URI .
          docker push $API_IMAGE_URI
          
          echo "image-uri=$API_IMAGE_URI" >> $GITHUB_OUTPUT
          echo "✅ API .NET 9: $API_IMAGE_URI"

      - name: Check builds
        id: check
        run: |
          echo "success=true" >> $GITHUB_OUTPUT

  terraform-deploy:
    name: 'Deploy Infraestrutura'
    runs-on: ubuntu-latest
    needs: build-lambda
    defaults:
      run:
        working-directory: infra/terraform/envs/prod
    outputs:
      terraform-success: ${{ steps.apply.outcome }}
      aurora-endpoint: ${{ steps.outputs.outputs.aurora-endpoint }}
      aurora-secret-arn: ${{ steps.outputs.outputs.aurora-secret-arn }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Configure AWS
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: sa-east-1

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: '1.6.0'
          terraform_wrapper: false

      - name: Download Lambda
        uses: actions/download-artifact@v4
        with:
          name: lambda-deployment-${{ github.run_id }}
          path: infra/terraform/envs/prod

      - name: Terraform Init
        run: |
          terraform init \
            -backend-config="bucket=${{ secrets.AWS_TF_STATE_BUCKET }}" \
            -backend-config="key=mana-food-prod.tfstate" \
            -backend-config="region=sa-east-1"

      - name: Terraform Apply
        id: apply
        run: |
          terraform plan -var="bucket_state_name=${{ secrets.AWS_TF_STATE_BUCKET }}" -out=tfplan
          terraform apply -auto-approve tfplan

      - name: Get Outputs
        id: outputs
        if: steps.apply.outcome == 'success'
        run: |
          AURORA_ENDPOINT=$(terraform output -raw aurora_endpoint)
          echo "aurora-endpoint=$AURORA_ENDPOINT" >> $GITHUB_OUTPUT
          
          # Obter ARN do secret do Aurora
          SECRET_ARN=$(aws rds describe-db-clusters --db-cluster-identifier mana-food-aurora --region sa-east-1 --query 'DBClusters[0].MasterUserSecret.SecretArn' --output text 2>/dev/null || echo "None")
          echo "aurora-secret-arn=$SECRET_ARN" >> $GITHUB_OUTPUT

  wait-aurora:
    name: 'Aguardar Aurora Disponível'
    runs-on: ubuntu-latest
    needs: terraform-deploy
    if: needs.terraform-deploy.outputs.terraform-success == 'success'
    outputs:
      connection-string: ${{ steps.connection.outputs.connection-string }}

    steps:
      - name: Configure AWS
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: sa-east-1

      - name: Wait for Aurora availability
        run: |
          echo "⏳ Aguardando Aurora estar disponível..."
          
          timeout 600 bash -c "
            while true; do
              STATUS=\$(aws rds describe-db-clusters --db-cluster-identifier mana-food-aurora --region sa-east-1 --query 'DBClusters[0].Status' --output text 2>/dev/null || echo 'unknown')
              if [ \"\$STATUS\" = \"available\" ]; then
                echo \"✅ Aurora disponível!\"
                break
              fi
              echo \"Status: \$STATUS - aguardando...\"
              sleep 30
            done
          "

      - name: Get connection string
        id: connection
        run: |
          SECRET_ARN="${{ needs.terraform-deploy.outputs.aurora-secret-arn }}"
          AURORA_ENDPOINT="${{ needs.terraform-deploy.outputs.aurora-endpoint }}"
          
          if [ "$SECRET_ARN" != "None" ] && [ "$SECRET_ARN" != "null" ] && [ -n "$SECRET_ARN" ]; then
            echo "🔐 Obtendo credenciais do AWS Secrets Manager..."
            SECRET_VALUE=$(aws secretsmanager get-secret-value --secret-id "$SECRET_ARN" --region sa-east-1 --query 'SecretString' --output text)
            DB_USERNAME=$(echo "$SECRET_VALUE" | jq -r '.username')
            DB_PASSWORD=$(echo "$SECRET_VALUE" | jq -r '.password')
          else
            echo "⚠️ Usando credenciais padrão"
            DB_USERNAME="admin"
            DB_PASSWORD="${{ secrets.DB_PASSWORD || 'TempPassword123!' }}"
          fi
          
          # Criar connection string para .NET
          CONNECTION_STRING="Server=$AURORA_ENDPOINT;Port=3306;Database=manafooddb;Uid=$DB_USERNAME;Pwd=$DB_PASSWORD;SslMode=Required;"
          
          echo "connection-string=$CONNECTION_STRING" >> $GITHUB_OUTPUT
          echo "✅ Connection string preparada para aplicação .NET 9"

  configure-lambda:
    name: 'Config Lambda .NET 9'
    runs-on: ubuntu-latest
    needs: [terraform-deploy, wait-aurora]

    steps:
      - name: Configure AWS
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: sa-east-1

      - name: Update Lambda with RDS connection
        run: |
          CONNECTION_STRING="${{ needs.wait-aurora.outputs.connection-string }}"
          AURORA_ENDPOINT="${{ needs.terraform-deploy.outputs.aurora-endpoint }}"
          
          echo "🔧 Configurando Lambda .NET 9 de autenticação..."
          
          # Configurar variáveis de ambiente da Lambda
          aws lambda update-function-configuration \
            --function-name mana-food-api \
            --region sa-east-1 \
            --environment Variables="{
              \"ConnectionStrings__DefaultConnection\":\"$CONNECTION_STRING\",
              \"ASPNETCORE_ENVIRONMENT\":\"Production\",
              \"DATABASE_HOST\":\"$AURORA_ENDPOINT\",
              \"DATABASE_NAME\":\"manafooddb\",
              \"DATABASE_PORT\":\"3306\"
            }"
          
          # Aguardar atualização
          aws lambda wait function-updated --function-name mana-food-api --region sa-east-1
          
          echo "✅ Lambda .NET 9 configurada para Aurora RDS"

  deploy-apps:
    name: 'Deploy Gateway & API .NET 9 no EKS'
    runs-on: ubuntu-latest
    needs: [terraform-deploy, build-apps, wait-aurora, configure-lambda]
    if: needs.build-apps.outputs.build-success == 'true'

    steps:
      - name: Configure AWS
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: sa-east-1

      - name: Setup kubectl
        uses: azure/setup-kubectl@v3

      - name: Deploy aplicações .NET 9 no EKS
        run: |
          aws eks update-kubeconfig --region sa-east-1 --name mana-food-eks
          
          # Configurações
          GATEWAY_IMAGE="${{ needs.build-apps.outputs.gateway-image }}"
          API_IMAGE="${{ needs.build-apps.outputs.api-image }}"
          AURORA_ENDPOINT="${{ needs.terraform-deploy.outputs.aurora-endpoint }}"
          CONNECTION_STRING="${{ needs.wait-aurora.outputs.connection-string }}"
          
          # Obter URL da Lambda de autenticação
          API_ID=$(aws apigateway get-rest-apis --query 'items[?name==`mana-food-api`].id' --output text)
          LAMBDA_AUTH_URL="https://$API_ID.execute-api.sa-east-1.amazonaws.com/prod"
          
          echo "🚀 Deployando ManaFood .NET 9 no EKS..."
          echo "🌐 Gateway .NET 9: $GATEWAY_IMAGE"
          echo "📱 API .NET 9: $API_IMAGE"
          echo "⚡ Lambda .NET 9: $LAMBDA_AUTH_URL"
          echo "🗄️ Aurora RDS: $AURORA_ENDPOINT"
          
          # Deploy seguindo arquitetura obrigatória
          kubectl apply -f - <<EOF
          # Secrets
          apiVersion: v1
          kind: Secret
          metadata:
            name: mana-food-secrets
            namespace: default
          type: Opaque
          stringData:
            connection-string: "$CONNECTION_STRING"
            lambda-auth-url: "$LAMBDA_AUTH_URL"
          ---
          # ConfigMap
          apiVersion: v1
          kind: ConfigMap
          metadata:
            name: mana-food-config
            namespace: default
          data:
            ASPNETCORE_ENVIRONMENT: "Production"
            ASPNETCORE_URLS: "http://+:8080"
            DATABASE_HOST: "$AURORA_ENDPOINT"
            DATABASE_NAME: "manafooddb"
            DATABASE_PORT: "3306"
          ---
          # API .NET 9 Deployment (aplica migrations automaticamente)
          apiVersion: apps/v1
          kind: Deployment
          metadata:
            name: mana-food-api
            namespace: default
          spec:
            replicas: 2
            selector:
              matchLabels:
                app: mana-food-api
            template:
              metadata:
                labels:
                  app: mana-food-api
              spec:
                containers:
                - name: api
                  image: $API_IMAGE
                  ports:
                  - containerPort: 8080
                  env:
                  - name: ConnectionStrings__DefaultConnection
                    valueFrom:
                      secretKeyRef:
                        name: mana-food-secrets
                        key: connection-string
                  envFrom:
                  - configMapRef:
                      name: mana-food-config
                  resources:
                    requests:
                      memory: "256Mi"
                      cpu: "250m"
                    limits:
                      memory: "512Mi"
                      cpu: "500m"
                  livenessProbe:
                    httpGet:
                      path: /swagger
                      port: 8080
                    initialDelaySeconds: 120
                    periodSeconds: 30
                  readinessProbe:
                    httpGet:
                      path: /swagger
                      port: 8080
                    initialDelaySeconds: 60
                    periodSeconds: 15
          ---
          # Gateway .NET 9 Deployment
          apiVersion: apps/v1
          kind: Deployment
          metadata:
            name: mana-food-gateway
            namespace: default
          spec:
            replicas: 2
            selector:
              matchLabels:
                app: mana-food-gateway
            template:
              metadata:
                labels:
                  app: mana-food-gateway
              spec:
                containers:
                - name: gateway
                  image: $GATEWAY_IMAGE
                  ports:
                  - containerPort: 8080
                  env:
                  - name: LambdaAuthUrl
                    valueFrom:
                      secretKeyRef:
                        name: mana-food-secrets
                        key: lambda-auth-url
                  - name: ApiUrl
                    value: "http://mana-food-api-service:80"
                  envFrom:
                  - configMapRef:
                      name: mana-food-config
                  resources:
                    requests:
                      memory: "128Mi"
                      cpu: "100m"
                    limits:
                      memory: "256Mi"
                      cpu: "250m"
          ---
          # API Service (interno)
          apiVersion: v1
          kind: Service
          metadata:
            name: mana-food-api-service
            namespace: default
          spec:
            selector:
              app: mana-food-api
            ports:
            - port: 80
              targetPort: 8080
            type: ClusterIP
          ---
          # Gateway Service (público)
          apiVersion: v1
          kind: Service
          metadata:
            name: mana-food-gateway-service
            namespace: default
          spec:
            selector:
              app: mana-food-gateway
            ports:
            - port: 80
              targetPort: 8080
            type: LoadBalancer
          EOF
          
          echo "⏳ Aguardando API aplicar migrations..."
          kubectl rollout status deployment/mana-food-api --timeout=900s
          
          echo "⏳ Aguardando Gateway..."
          kubectl rollout status deployment/mana-food-gateway --timeout=300s

      - name: Verificar arquitetura deployada
        run: |
          echo "📊 Status da arquitetura ManaFood:"
          kubectl get pods -o wide
          kubectl get svc -o wide
          
          echo ""
          echo "🔍 Logs da API (migrations):"
          kubectl logs deployment/mana-food-api --tail=20 || echo "Logs ainda não disponíveis"
          
          echo ""
          echo "🌐 Aguardando Load Balancer do Gateway..."
          
          timeout 300 bash -c '
            while true; do
              LB_HOSTNAME=$(kubectl get svc mana-food-gateway-service -o jsonpath="{.status.loadBalancer.ingress[0].hostname}" 2>/dev/null)
              if [ -n "$LB_HOSTNAME" ] && [ "$LB_HOSTNAME" != "null" ]; then
                echo "🔗 ManaFood Gateway: http://$LB_HOSTNAME"
                echo ""
                echo "✅ ARQUITETURA MANA FOOD DEPLOYADA!"
                echo "🏗️ Fluxo: Internet → Gateway .NET 9 → {Lambda .NET 9 (auth) + API .NET 9 (business)} → Aurora RDS"
                echo "📋 Aplicação .NET 9 aplicou migrations automaticamente"
                echo "⚡ Lambda .NET 9 e API .NET 9 conectadas ao mesmo Aurora RDS"
                break
              fi
              echo "⏰ Aguardando Load Balancer..."
              sleep 30
            done
          ' || echo "⚠️ Timeout aguardando Load Balancer"

  status:
    name: 'Status Final'
    runs-on: ubuntu-latest
    needs: [terraform-deploy, build-apps, wait-aurora, configure-lambda, deploy-apps]
    if: always()

    steps:
      - name: Generate report
        run: |
          echo "🎯 MANA FOOD - ARQUITETURA OBRIGATÓRIA"
          echo "======================================"
          echo "Infraestrutura: ${{ needs.terraform-deploy.result }}"
          echo "Build Apps: ${{ needs.build-apps.result }}"
          echo "Aurora Wait: ${{ needs.wait-aurora.result }}"
          echo "Lambda Config: ${{ needs.configure-lambda.result }}"
          echo "Apps Deploy: ${{ needs.deploy-apps.result }}"
          echo ""
          
          if [ "${{ needs.deploy-apps.result }}" = "success" ]; then
            echo "✅ MANA FOOD DEPLOYADO SEGUINDO REGRAS OBRIGATÓRIAS!"
            echo ""
            echo "🏗️ ARQUITETURA IMPLEMENTADA:"
            echo "  🗄️ Aurora MySQL RDS - Banco central único"
            echo "  ⚡ Lambda .NET 9 - Autenticação (serverless AWS)"
            echo "  🌐 Gateway .NET 9 - Proxy (EKS)"
            echo "  📱 API .NET 9 - Business + Migrations automáticas (EKS)"
            echo ""
            echo "🔄 FLUXO CORRETO:"
            echo "  Cliente → Gateway .NET 9 → {Lambda .NET 9 (auth) + API .NET 9 (business)} → Aurora RDS"
            echo ""
            echo "✅ REGRAS SEGUIDAS:"
            echo "  • Aurora RDS como fonte única"
            echo "  • Aplicação aplica migrations na inicialização"
            echo "  • Lambda serverless AWS + Gateway/App no EKS"
            echo "  • Todos conectam ao mesmo Aurora MySQL"
            echo "  • NÃO usou setup via Docker externo"
          else
            echo "❌ Falha no deployment"
          fi